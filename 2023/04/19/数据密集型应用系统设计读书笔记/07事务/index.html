<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/function%20()%20%7B%0A%20%20%20%20%20%20for%20(var%20_len2%20=%20arguments.length,%20args%20=%20new%20Array(_len2),%20_key2%20=%200;%20_key2%20%3C%20_len2;%20_key2++)%20%7B%0A%20%20%20%20%20%20%20%20args%5B_key2%5D%20=%20arguments%5B_key2%5D;%0A%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20return%20obj%5Bval%5D.apply(obj,%20args);%0A%20%20%20%20%7D">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","width":160,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="事务使得应用程序可以忽略数据库内部一些复杂的并发问题，以及软硬件故障，简化应用层的处理逻辑。本章深入探讨了并发控制。介绍了多个广泛使用的隔离级别，特别是读已提交，快照隔离（或可重复读取）与可串行化。通过分析如何处理异常来阐述这些隔离级别的要点：">
<meta property="og:type" content="article">
<meta property="og:title" content="DDIA笔记-07事务">
<meta property="og:url" content="http://example.com/2023/04/19/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/07%E4%BA%8B%E5%8A%A1/index.html">
<meta property="og:site_name" content="gqtc&#39;s blog">
<meta property="og:description" content="事务使得应用程序可以忽略数据库内部一些复杂的并发问题，以及软硬件故障，简化应用层的处理逻辑。本章深入探讨了并发控制。介绍了多个广泛使用的隔离级别，特别是读已提交，快照隔离（或可重复读取）与可串行化。通过分析如何处理异常来阐述这些隔离级别的要点：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/07事务/image-20230815082321923.png">
<meta property="og:image" content="http://example.com/img/07事务/image-20230815162021759.png">
<meta property="og:image" content="http://example.com/img/07事务/image-20230815162048913.png">
<meta property="og:image" content="http://example.com/img/07事务/image-20230815191958643.png">
<meta property="og:image" content="http://example.com/img/07事务/image-20230815200937419.png">
<meta property="og:image" content="http://example.com/img/07%E4%BA%8B%E5%8A%A1/image-20230818081412442.png">
<meta property="og:image" content="http://example.com/img/07事务/ch07-fig10.png">
<meta property="og:image" content="http://example.com/img/07事务/ch07-fig11.png">
<meta property="article:published_time" content="2023-04-18T16:00:00.000Z">
<meta property="article:modified_time" content="2024-02-15T03:00:09.676Z">
<meta property="article:author" content="gqtc">
<meta property="article:tag" content="分布式">
<meta property="article:tag" content="一致性">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/07事务/image-20230815082321923.png">

<link rel="canonical" href="http://example.com/2023/04/19/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/07%E4%BA%8B%E5%8A%A1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>DDIA笔记-07事务 | gqtc's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">gqtc's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/19/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/07%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/panda.gif">
      <meta itemprop="name" content="gqtc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gqtc's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          DDIA笔记-07事务
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-19 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-19T00:00:00+08:00">2023-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-15 11:00:09" itemprop="dateModified" datetime="2024-02-15T11:00:09+08:00">2024-02-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">数据密集型应用系统设计读书笔记</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/04/19/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/07%E4%BA%8B%E5%8A%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/04/19/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/07%E4%BA%8B%E5%8A%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>事务使得应用程序可以忽略数据库内部一些复杂的并发问题，以及软硬件故障，简化应用层的处理逻辑。本章深入探讨了并发控制。介绍了多个广泛使用的隔离级别，特别是读已提交，快照隔离（或可重复读取）与可串行化。通过分析如何处理异常来阐述这些隔离级别的要点：</p>
<span id="more"></span>

<ul>
<li>脏读：客户端读到了其他客户端尚未提交的写入。读已提交以及更强的隔离级别可以防止脏读。</li>
<li>脏写：客户端覆盖了另一个客户端尚未提交的写入。几乎所有的数据库实现都可以防止脏写。</li>
<li>读倾斜（不可重复读）：客户在不同的时间点看到了不同值。快照隔离是最用的防范手段， 即事务总是在某个时间点的一致性快照中读取数据。通常采用多版本并发控制（ MVCC ）来实现快照隔离。</li>
<li>更新丢失：两个客户端<font color=red>同时执行读-修改-写入操作</font>序列，其中一个覆盖了另一个的写入，但又没有包含对方最新值，最终导致了部分修改数据发生了丢失。快照隔离的一些实现可以自动防止这种异常，而另一些则需要手动锁定查询结果(SELECT FOR UPDATE)。</li>
<li>写倾斜：事务先查询数据，根据返回的结果而作出某些决定，然后修改数据库。当事务提交时，支持决定的前提条件已不再成立。只有可串行化的隔离才能防止这种异常。</li>
<li>幻读：事务读取了某些符合查询条件的对象，同时另一个客户端执行写入，改变了先前的查询结果。快照隔离可以防止简单的幻读，但写倾斜情况则需要特殊处理，例如采用区间范围锁。</li>
</ul>
<p>只有可串行化的隔离可以防止所有这些问题。实现可串行化隔离的三种不同方法：</p>
<ul>
<li>严格串行执行事务：如果每个事务的执行速度非常快，且单个CPU核可以满足事务的吞吐量要求，严格串行执行是一个非常简单有效的方案。</li>
<li>两阶段加锁：几十年来一直是实现可串行化的标准方式，但还是有很多系统出于性能原因而放弃使用它。</li>
<li>可串行化的快照隔离(SSI)：一种最新的算法，可避免前面方法的大部分缺点。它秉持乐观预期的原则，允许多个事务并发执行而不阻塞；仅当事务尝试提交时，才检查可能的冲突，如果发现违背了串行化，某些事务会被中止。</li>
</ul>
<p>本章介绍的方案主要针对单节点。对于分布式数据库，还会面临更多、更复杂的挑战，后面的章节会讨论。</p>
<hr>
<p>一个苛刻的数据存储环境中，会有许多可能出错的情况：</p>
<ul>
<li>数据库软件或硬件可能会随时失效（包括正在执行写操作的过程中）；</li>
<li>应用程序可能随时崩溃；</li>
<li>应用与数据库节点间，数据库节点之间的链接可能随时会中断；</li>
<li>多个客户端可能同时写入数据库，导致数据覆盖；</li>
</ul>
<p>近十年来，<font color=red>事务技术一直是简化这些问题的首选机制</font>。事务被人为创造出来，目的是简化应用层的编程模型。有了事务，应用程序不用考虑某些内部潜在的错误以及复杂的并发性问题，由事务来提供安全性保证。</p>
<p>并非每个应用程序都需要事务机制，有时可以弱化事务或完全放弃事务（例如为实现更高的性能或更高的可用性）。</p>
<h3 id="深入理解事务"><a href="#深入理解事务" class="headerlink" title="深入理解事务"></a>深入理解事务</h3><p>事务的概念几十年中几乎没发生变化。换句话说，MySQL、PostgreSQL、Oracle、SQL Server等系统实现的事务与当年IBM在1975年推出的第一个SQL数据库SystemR非常相似。</p>
<p>21世纪末，非关系(NoSQL)数据库开始兴起。它们完全放弃了事务，或将其重新定义，即提供为比以前弱得多的保证。</p>
<p>与其他技术一样，事务有其优势，也有其自身的局限性。</p>
<h4 id="ACID的含义"><a href="#ACID的含义" class="headerlink" title="ACID的含义"></a>ACID的含义</h4><p>ACID，分别代表原子性（Atomicity），一致性（Consistency），隔离性（Isolation）与持久性（Durability）。实际上，<font color=red>各家数据库所实现的ACID并不尽相同，围绕着“隔离性”就存在很多含糊不清的争议。</font></p>
<p>不符合ACID标准的系统有时被冠以<font color=red>BASE</font>，即基本可用性（Basically Available），软状态（Soft state）和最终一致性（ Eventual consistency)。它比ACID更模棱两可。</p>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>原子这个术语在计算机的不同领域里有相似但微妙的差异。ACID中的原子性不关乎多个操作的并发性，它没有描述多个线程试图访问相同的数据会发生什么情况，后者其实是由ACID的隔离性所定义。</p>
<p>ACID原子性保证如果事务中止，应用程序可以确定没有实质发生任何更改，所以可以安全地重试。因此ACID中原子性所定义的特征是：出错时中止事务，并将部分完成的写入全部丢弃。</p>
<h5 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h5><p>一致性非常重要，但它在不同场景有不同的具体含义。ACID中的一致性的主要指<font color=red>对数据有特定的预期状态</font>，任何数据更改必须满足这些状态约束。例如一个账单系统，账户的贷款余额应和借款余额保持平衡。如果某事务从一个有效的状态开始，并且事务中任何更新操作都没有违背约束，那么最后的结果依然符合有效状态。</p>
<p>这种<font color=red>一致性本质上要求应用层来维护状态一致</font>，应用程序有责任正确地定义事务来保持一致性。这不是数据库可以保证的事情：即如果提供的数据修改违背了恒等条件，数据库很难检测进而阻止该操作。</p>
<p>原子性，隔离性和持久性是数据库自身的属性，而一致性更多是应用层的属性。<font color=red>应用程序可能借助数据库提供的原子性和隔离性，以达到一致性，但一致性本身并不属于数据库。</font></p>
<h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h5><p>多个客户端同时访问数据库，若访问相同的记录，可能会遇到并发问题（即竞争条件）。ACID中的隔离性表示<font color=red>并发执行的多个事务相互隔离，不能互相交叉</font>。经典的数据库教材把隔离定义为可串行化，这表示可以假装它是数据库上运行的唯一事务。虽然实际上它们可能同时运行，但数据库系统确保当事务提交时，其结果与串行执行（一个接一个）完全相同。</p>
<p>然而<font color=red>实践中，由于性能问题很少使用串行化隔离。</font>一些流行的数据库，如Oracle 11g甚至根本就没实现它。Oracle虽然也有声称“串行化”的功能，但它本质上实现的是快照隔离，后者提供了比串行化更弱的保证。</p>
<h5 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h5><p>数据库系统本质上是提供一个安全可靠的地方来存储数据而不用担心数据丢失等问题。持久性就是这样的承诺，它保证一旦事务提交成功，即使存在硬件故障或数据库崩溃，事务所写入的任何数据也不会消失。</p>
<p>对于单节点数据库，持久性通常表示数据已写入非易失性存储设备。写入过程中，通常还涉及预写日志等，这样万一磁盘数据损坏可以恢复。而对于支持远程复制的数据库，持久性表示数据已成功复制到多个节点。为实现持久性的保证，<font color=red>数据库必须等到这些写入或复制完成之后才能报告事务成功提交。</font></p>
<p>其实不存在完美的持久性。例如，所有的硬盘和所有的备份如果都同时被销毁，那么数据库也无能为力。</p>
<h4 id="单对象与多对象事务操作"><a href="#单对象与多对象事务操作" class="headerlink" title="单对象与多对象事务操作"></a>单对象与多对象事务操作</h4><p>总结来说，在ACID中，原子性和隔离性是数据库对用户进行多个写入时需提供的保证，并且它们通常假设一个事务中会同时修改多个对象（rows、documents 和 records）。相比单对象事务（single-object transaction），这种多对象事务（multi-objects transaction）是一种更强的保证，且更常用，因为通常多个写入不会只针对单个对象。</p>
<p>在多对象事务中，一个关键点是如何确定多个操作是否属于同一事务：</p>
<ol>
<li>从物理上来考虑。可以通过 TCP 连接来确定，在同一个连接中，<code>BEGIN TRANSACTION</code> 和  <code>COMMIT</code>语句之间的所有内容，可以认为属于同一个事务。但会有一些 corner case，如在客户端提交请求后，服务器确认提交之前，网络中断，连接断开，此时客户端则无从得知事务是否被成功提交。</li>
<li>从逻辑上来考虑。使用事务管理器，为每个事务分配一个唯一标识符，从而对操作进行分组。</li>
</ol>
<p>实际中基本上使用第二种方法。</p>
<h3 id="弱隔离级别"><a href="#弱隔离级别" class="headerlink" title="弱隔离级别"></a>弱隔离级别</h3><p>某事务修改数据而另一事务同时要读该数据，或两个事务同时修改相同数据时，会引发并发问题（引入竞争条件）。</p>
<p>数据库一直试图通过事务隔离来对应用开发者隐藏内部的各种并发问题。理论上讲，<font color=red>隔离是假装没有发生并发</font>，而可串行化隔离意味着数据库保证事务的最终执行结果与串行（即一次一个，没任何并发）执行结果相同。</p>
<p>可串行化的隔离会严重影响性能，许多数据库不想牺牲性能，因而倾向于采用较弱的隔离级别，弱隔离级别可以防止某些但非全部的并发问题。弱隔离级别可能会带来一些难以捉摸的隐患，但在实践中还是被广泛使用。很多流行的关系数据库系统（通常被认为是“ ACID兼容”）其实也采用的是弱级别隔离。</p>
<h4 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h4><p>读已提交是最基本的的事务隔离级别，它只提供以下两个保证：</p>
<ul>
<li>读数据库时，只能看到已成功提交的数据（防止“脏读”）。</li>
<li>写数据库时，只会覆盖已成功提交的数据（防止“脏写”）。</li>
</ul>
<h5 id="防止脏读"><a href="#防止脏读" class="headerlink" title="防止脏读"></a>防止脏读</h5><p>若某事务已完成部分数据写入，且尚未提交（或中止），此时另一事务是否可以看到尚未提交的数据？若是，则是脏读。</p>
<p>读已提交级别的事务隔离必须做到防止脏读。如图7-4所示，用户1设置了x &#x3D; 3，在用户1的事务未提交之前，用户2的get x操作依旧返回的是旧值2。</p>
<img src="/img/07事务/image-20230815082321923.png" alt="image-20230815082321923" style="zoom:67%;" />

<p>当有以下需求时，需防止脏读：</p>
<ul>
<li>如果<font color=red>事务要更新多个对象</font>，脏读意味着另一个事务可能会看到部分更新，而非全部。观察到部分更新的数据可能会引发一些不必要的后续操作。</li>
<li>如果<font color=red>事务中止，则所有写入操作都要回滚</font>。如果发生脏读，意味着它可能会看到一些稍后被回滚的数据，这些数据并未实际提交到数据库中。之后所引发的后果可能都会变得难以预测。</li>
</ul>
<h5 id="防止脏写"><a href="#防止脏写" class="headerlink" title="防止脏写"></a>防止脏写</h5><p>若两个事务同时尝试更新相同的对象，后写的操作会覆盖较早的写入，这没问题。但如果先前的写入是尚未提交事务的一部分，是否还是被覆盖？如果是，那就是脏写。</p>
<p>读提交隔离级别下所提交的事务可以防止脏写，通常的方式是推迟第二个写请求，直到前面的事务完成提交（或中止）。防止脏写可以避免以下并发问题：</p>
<ul>
<li><p>如果<font color=red>事务要更新多个对象</font>，脏写会带来非预期的错误结果。如图7-5的二手车网站的例子，Alice和Bob两人试图购买同一辆车。购买汽车需两次数据库写入：商品买主需更新为新买家，销售发票也要随之更新。图中，车主被改为Bob，但发票却发给了Alice。读提交隔离要防止这种事故。</p>
<img src="/img/07事务/image-20230815162021759.png" alt="image-20230815162021759" style="zoom: 67%;" />
</li>
<li><p>但读已提交隔离不能解决图7-1中计数器增量的竞争情况。第二次写入确实在第一个事务提交后才执行，虽不属于脏写，但结果仍然是错的。在接下来的“防止更新丢失”中，将讨论如何安全递增计数器。</p>
<img src="/img/07事务/image-20230815162048913.png" alt="image-20230815162048913" style="zoom:67%;" /></li>
</ul>
<h5 id="实现读已提交"><a href="#实现读已提交" class="headerlink" title="实现读已提交"></a>实现读已提交</h5><p>数据库通常<font color=red>采用行级锁防止脏写</font>：当事务修改某对象（例如行或文档）时，它必须先获得该对象的锁；然后一直持有锁直到事务提交（或中止）。此时如果有另一事务尝试更新同一对象，则必须等待，直到前面的事务完成提交（或中止）。这种锁定是由处于读已提交模式（或更强的隔离级别）数据库自动完成的。</p>
<p>那如何防止脏读呢？ 一种选择是使用相同的锁，所有试图读取该对象的事务必须先申请锁，读取完成后释放锁。从而确保当有脏数据时不会有读操作（<font color=red>因为写事务已经持有了锁</font>）。然而，读锁的方式在实际中并不可行，因为运行时间较长的写事务会导致许多只读的事务等待太长时间，严重影响只读事务的响应延迟。</p>
<p>因此，多数数据库采用防止脏读的方法是：对每个待更新的对象，数据库<font color=red>维护其旧值和当前持锁事务将要设置的新值两个版本</font>。事务提交之前，所有其他读操作都读取旧值；仅当写事务提交之后，才会切换到读取新值。</p>
<h4 id="快照级别隔离与可重复读"><a href="#快照级别隔离与可重复读" class="headerlink" title="快照级别隔离与可重复读"></a>快照级别隔离与可重复读</h4><p>使用读已提交隔离级别时，仍然有很多场景可能导致并发错误。</p>
<img src="/img/07事务/image-20230815191958643.png" alt="image-20230815191958643" style="zoom: 50%;" />

<p>Alice在银行有两个500美元的账户，共1000美元。现在有一笔转账交易从账户1转100美元到账户2。如果在银行数据库系统执行转账的过程中间，查看两个账户的余额，她可能会看到账号2在收到转账之前的余额（500美元），如果在交易结束时再次读取账户2的余额，她将看到不同的值（600美元）。这种异常现象被称为不可重复读取或读倾斜（read skew）。</p>
<p><font color=red>快照级别隔离是解决该问题最常见的手段</font>。其思路是，每个事务从数据库的一致性快照中读取，事务一开始所看到是最近提交的数据，即使数据随后可能被另一个事务更改，但保证每个事务都只看到该特定时间点的旧数据。</p>
<p>快照级别隔离非常流行，目前PostgreSQL, MySQL的InnoDB存储引擎都已经支持。</p>
<h5 id="实现快照级别隔离"><a href="#实现快照级别隔离" class="headerlink" title="实现快照级别隔离"></a>实现快照级别隔离</h5><p>与读已提交隔离类似，快照级别隔离的实现通常采用写锁来防止脏写，即正在写操作的事务会阻止同一对象上的其他事务的写操作。但是，读取则不需要任何锁。<font color=red>从性能角度看，快照级别隔离的一个关键点是读操作不会阻塞写操作，写操作也不阻塞读操作。</font></p>
<p>为实现快照级别隔离，考虑到多个正在进行的事务可能会在不同的时间点查看数据库状态，所以数据库保留对象多个不同的提交版本，这种技术因此也称为<font color=red>多版本并发控制（Multi-Version Concurrency Control, MVCC）。</font></p>
<p>为啥需要多个版本，而非两个版本，考虑下面的场景。T2和T3都是写事务，他们都会创建相应的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T1:    |------------R-------------|</span><br><span class="line">T2:        |------w-----|</span><br><span class="line">T3:	                         |---w--|</span><br><span class="line">T4:                       |-R-|</span><br></pre></td></tr></table></figure>

<p>如果只是为提供读已提交级别隔离，而不是完整的快照级别隔离，则只保留对象的两个版本就足够了：一个己提交的旧版本和尚未提交的新版本。然而，支持快照级别隔离的存储引擎往往直接采用MVCC来实现读已提交隔离。典型的做法是，在读已提交级别下，<font color=red>对每个查询单独创建一个快照；而快照级别隔离则是运行整个事务期间使用一个快照。</font></p>
<img src="/img/07事务/image-20230815200937419.png" alt="image-20230815200937419" style="zoom: 67%;" />

<p>图7-7说明了PostgreSQL如何实现基于MVCC的快照级别隔离（其他实现类似）。事务开始时，首先赋予一个唯一的单调递增的事务ID。事务向数据库写入新内容时，所写的数据会被标记写入者的事务ID。</p>
<p>表中每一行都有一个created_by字段，其中包含了创建该行的事务ID。每一行还有一个deleted_by字段，初始为空。如果有事务要删除某行，该行只是将deleted_by字段设置为请求删除的事务ID（仅标记为删除，而不实际删除）。一段时间后，当确定没有其他事务引用该标记删除的行时，<font color=red>数据库的垃圾回收进程才真正删除并释放存储空间。</font></p>
<p>因此，一次更新操作在内部被转换为一个删除操作加一个创建操作。如图7-7中，事务13从账户2中扣除100美元，余额从500减为400美元。accounts表里会出现两行账户2：一个余额为$500但标记为删除的行（由事务13删除），另一个余额为$400 ，由事务13创建。</p>
<h5 id="一致性快照的可见性规则"><a href="#一致性快照的可见性规则" class="headerlink" title="一致性快照的可见性规则"></a>一致性快照的可见性规则</h5><p>当事务读数据库时，<font color=red>通过事务ID可以决定哪些对象可见</font>，哪些不可见。要想对上层应用维护好快照的一致性，需要精心定义数据的<font color=red>可见性规则</font>。例如：</p>
<ol>
<li>每笔事务开始时，数据库列出所有当前尚在进行中的其他事务（即尚未提交或中止），忽略这些事务的部分写入（尽管之后可能会被提交），即不可见。</li>
<li>所有中止事务所做的修改全部不可见。</li>
<li>较晚事务ID（即晚于当前事务）所做的任何修改不可见，不管这些事务是否完成了提交。</li>
<li>除此之外，其他所有的写入都对应用查询可见。</li>
</ol>
<p>以上规则适用于创建操作和删除操作。图7-7中，当事务12从账户2读取时，它看到的是$500的余额，因为删除操作是由稍后事务13所产生的，同理，400美元余额的创建操作也不可见。</p>
<p>换句话说，仅当以下两个条件都成立，则数据对象对事务可见：</p>
<ul>
<li>事务开始的时刻，创建该对象的事务已经完成了提交。</li>
<li>对象没有被标记为删除；或者即使标记了，但删除事务在当前事务开始时还没有完成提交。</li>
</ul>
<h5 id="索引与快照级别隔离"><a href="#索引与快照级别隔离" class="headerlink" title="索引与快照级别隔离"></a>索引与快照级别隔离</h5><p>接下来一个问题是，这种多版本数据库该如何支持索引呢？一种方案是<font color=red>索引直接指向对象的所有版本</font>，然后想办法过滤对当前事务不可见的那些版本。当后台的垃圾回收进程决定删除某个旧对象版本时，对应的索引条目也需要随之删除。</p>
<p>在实践中，有许多细节决定了多版本并发控制的实际性能。例如，可以把同一对象的不同版本放在一个内存页面上，PostgreSQL采取这样的优化措施来避免更新索引。</p>
<p>CouchDB使用另一种方法。它们主体结构是B-tree，但采用了一种追加&#x2F;写时复制的技术。更新时，不会修改现有的页面，而总是创建一个新的修改副本，拷贝必要的内容，然后让父结点，或者递归向上直到树的root结点都指向新创建的结点。那些不受更新影响的页面都不需要复制，保持不变并被父结点所指向。</p>
<p>这种采用追加式的B-tree，<font color=red>每个写入事务（或一批事务）都会创建一个新的B-tree root</font>，代表该时刻数据库的一致性快照。这时就没有必要根据事务ID再去过滤某些对象，每笔写入都会修改现有的B-tree，因为之后的查询可以直接作用于特定快照B-tree（有利于查询性能）。采用这种方法依然需要后台进程来执行压缩和垃圾回收。</p>
<h5 id="可重复读与命名混淆"><a href="#可重复读与命名混淆" class="headerlink" title="可重复读与命名混淆"></a>可重复读与命名混淆</h5><p>快照级别隔离对于只读事务特别有效。但是，具体到实现，许多<font color=red>数据库对它有着不同的命名</font>。Oracle称之为可串行化， PostgreSQL和MySQL则称为可重复读。</p>
<p>这种命名混淆的原因是<font color=red>SQL标准并没有定义快照级别隔离</font>，而仍然是基于老的System R 1975年所定义的隔离级别，当时还没有出现快照级别隔离。标准定义的是“可重复读”，看起来比较接近于快照级别隔离，所以PostgreSQL和MySQL称它们的快照级别隔离为“可重复读”，这符合标准要求（即合规性）。</p>
<p>然而必须指出，SQL标准对隔离级别的定义还是存在一些缺陷，某些定义模棱两可，不够精确，且不能做到与实现无关。尽管有几个数据库实现了可重复读，表面上看符合标准，但它们实际所提供的保证却大相径庭。可重复读有一个更为严谨的定义，然而大多数实现并没有遵循它。最后还要指出，IBM DB2 的“可重复读”实则是可串行化级别隔离。</p>
<h4 id="防止更新丢失"><a href="#防止更新丢失" class="headerlink" title="防止更新丢失"></a>防止更新丢失</h4><p>读已提交和快照级别隔离都是为了解决只读事务遇到并发写时可以看到什么（虽然中间也涉及脏写问题），还有另一种情况，即两个写事务并发，而脏写只是写并发的一个特例。</p>
<p>写事务并发还会带来其他冲突问题，最著名的就是更新丢失问题，比如前面图7-1的例子。更新丢失可能发生在这样一个操作场景中：应用从数据库读取某些值，根据应用逻辑做出修改，然后写回新值。当两个事务在<font color=red>同样的数据对象上</font>执行类似操作时，可能会导致某个事务的<font color=red>修改值丢失</font>（<em>个人理解：不是被覆盖，而是丢失。比如考虑计数器加1的例子，两个事务对计数器加1，结束后计数器应该加了2，但是因为更新丢失了，最终计数器只加了1</em>）。</p>
<p>并发写事务冲突是一个普遍问题，目前有多种可行的解决方案。</p>
<h5 id="原子写操作"><a href="#原子写操作" class="headerlink" title="原子写操作"></a>原子写操作</h5><p>许多数据库提供了原子更新操作，以避免在应用层完成“读-修改-写回”操作。例如，以下指令在多数关系数据库中都是并发安全的：<code>UPDATE counters SET value = value + 1 WHERE key = ’100 ’;</code></p>
<p>虽然并非所有更新操作都能以原子操作的方式来表达，但无论如何，<font color=red>如果原子操作可行，那它就是推荐的最佳方式。</font></p>
<p>原子操作通常采用<font color=red>对读取对象加独占锁</font>的方式来实现，这样在更新被提交之前不会其他事务可以读它。这种技术有时被称为<font color=red>游标稳定性</font>。另一种实现方式是强制所有的原子操作都在单线程上执行。</p>
<h5 id="显式加锁"><a href="#显式加锁" class="headerlink" title="显式加锁"></a>显式加锁</h5><p>另一种防止更新丢失的方法是由应用程序显式锁定待更新的对象。然后，应用执行“读-修改-写回”这样的操作序列。此时如果有其他事务尝试同时读取对象，则必须等待当前正在执行的序列全部完成。例如，示例7-1显式锁定行以防丢失更新。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> figures <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;robot&#x27;</span> <span class="keyword">AND</span> game_id <span class="operator">=</span> <span class="number">222</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Check whether move is valid, then update the position</span></span><br><span class="line"><span class="comment">-- of the piece that was returned by the previous SELECT. </span></span><br><span class="line"><span class="keyword">UPDATE</span> figures <span class="keyword">SET</span> position <span class="operator">=</span> <span class="string">&#x27;c4&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1234</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>FOR UPDATE指令指示数据库对返回的所有结果行要加锁。</p>
<p>首先该方法是可行的，但要做到这一点，需仔细考虑清楚应用层的逻辑。</p>
<h5 id="自动检测更新丢失"><a href="#自动检测更新丢失" class="headerlink" title="自动检测更新丢失"></a>自动检测更新丢失</h5><p>原子操作和锁都是通过强制“读-修改-写回”操作序列串行执行来防止丢失更新。另一种思路则是先让他们并发执行，但如果事务管理器<font color=red>检测到了更新丢失风险，则中止当前事务</font>，并强制回退到安全的“读-修改-写回”方式。</p>
<p>该方法的一个优点是数据库完全可以借助快照级别隔离来高效地执行检查。PostgreSQL的可重复读，Oracle的可串行化以及SQL Server的快照级别隔离等，都可以自动检测何时发生了更新丢失，然后中止违规的那个事务。更新丢失检测是个非常赞的功能。但MySQL&#x2F;InnoDB的可重复读却并不支持检测更新丢失。</p>
<h5 id="原子比较和设置"><a href="#原子比较和设置" class="headerlink" title="原子比较和设置"></a>原子比较和设置</h5><p>在不提供事务支持的数据库中，它们可能<font color=red>支持原子地“比较和设置”操作</font>。使用该操作可避免更新丢失。例如，为防止两个用户同时更新同一wiki页面，可以尝试下面的操作，只有当页面从上次读取之后没发生变化时，才会执行当前的更新：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- This may or may not be safe, depending on the database implementation</span></span><br><span class="line"><span class="keyword">UPDATE</span> wiki_pages <span class="keyword">SET</span> content <span class="operator">=</span> <span class="string">&#x27;new content&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1234</span> <span class="keyword">AND</span> content <span class="operator">=</span> <span class="string">&#x27;old content&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果内容的值与“旧内容”不匹配，则更新将失败，需要应用层再次检查并在必要时进行重试。注意，如果WHERE语句运行在数据库的某个旧的快照上，即使另一个并发写入正在运行，条件可能仍然为真，最终可能无法防止更新丢失问题。所以使用之前，<font color=red>应首先仔细检查“比较-设置”操作的安全运行条件。</font></p>
<h5 id="多副本和冲突解决"><a href="#多副本和冲突解决" class="headerlink" title="多副本和冲突解决"></a>多副本和冲突解决</h5><p>支持多副本的数据库，防止丢失更新还需考虑另一个维度：不同的节点可能会并发修改数据，因此<font color=red>必须采取一些额外措施来防止丢失更新。</font></p>
<p>加锁和原子修改的前提都是只有一个最新的数据副本。然而，对于多主节点或者无主节点的多副本数据库，由于支持多个并发写，且通常以异步方式来同步更新，所以会出现多个最新的数据副本。此时加锁和原子比较将不再适用。</p>
<p>“最后写入获胜（LWW）”冲突解决方法容易丢失更新。但目前LWW是许多多副本数据库的默认配置。</p>
<h4 id="写倾斜与幻读"><a href="#写倾斜与幻读" class="headerlink" title="写倾斜与幻读"></a>写倾斜与幻读</h4><p>这还不是并发写所引发的全部问题。例如：开发医生轮班的系统。医院安排多个医生值班，医生可以申请调整班次（例如医生临时有事），但前提是确保至少一位医生还在该班次中值班。现在Alice和Bob两位值班医生，碰巧都身体不适，因而都决定请假。不幸的是，他们几乎同一时刻点击了调班按钮。如下图：</p>
<p><img src="/img/07%E4%BA%8B%E5%8A%A1/image-20230818081412442.png" alt="image-20230818081412442"></p>
<p>每笔事务都是先检查是否至少有两名医生目前在值班。若是，则有一名医生可以安全离开。假设使用快照级别隔离，两个检查都返回有两名医生，两个事务都安全地进入到下一阶段。接下来Alice和Bob都更新自己的值班记录为离开。两个事务都成功提交，最后的结果却是没有任何医生在值班，显然这<font color=red>违背了至少一名医生值班的业务要求</font>。</p>
<h5 id="定义写倾斜"><a href="#定义写倾斜" class="headerlink" title="定义写倾斜"></a>定义写倾斜</h5><p>这种异常称为写倾斜。它既不是一种脏写，也不是更新丢失，两笔事务<font color=red>更新的是两个不同的对象</font>。这里的写冲突并不那么直接，试想，若两笔事务是串行执行，则第二个医生的申请肯定被拒绝。</p>
<p>可以将写倾斜视为一种<font color=red>更广义的更新丢失。两个事务读相同的一组对象，然后更新其中一部分：不同的事务若更新不同的对象，则可能发生写倾斜；而不同的事务若更新的是同一对象，则可能发生脏写或更新丢失（具体取决于时间窗口）。</font></p>
<p>对于写倾斜：</p>
<ul>
<li><p>涉及多个对象，单对象的原子操作不起作用。</p>
</li>
<li><p>基于快照级别隔离来实现更新丢失自动检测也有问题：目前所有的数据库实现，包括PostgreSQL的可重复读，MySQL&#x2F;InnoDB可重复读，Oracle可串行化等都不支持检测写倾斜问题。自动防止写倾斜要求真正的可串行化隔离。</p>
</li>
<li><p>虽然有些数据库允许指定约束（constraints），但往往是单对象的简单约束，如唯一性、外键约束。当然，可以使用触发器来在应用层维护多对象约束，以解决上述问题。</p>
</li>
<li><p>若不能使用可串行化级别隔离，次优的选择是对事务依赖的行来显式的加锁。比如上述医生值班的例子，可以：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> doctors</span><br><span class="line">    <span class="keyword">WHERE</span> on_call <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">AND</span> shift_id <span class="operator">=</span> <span class="number">1234</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> doctors</span><br><span class="line">    <span class="keyword">SET</span> on_call <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line">    <span class="keyword">AND</span> shift_id <span class="operator">=</span> <span class="number">1234</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--FOR UPDATE 语句会通知数据库对返回的所有结果行自动加锁。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="更多写倾斜的例子"><a href="#更多写倾斜的例子" class="headerlink" title="更多写倾斜的例子"></a>更多写倾斜的例子</h5><h6 id="会议室预订系统"><a href="#会议室预订系统" class="headerlink" title="会议室预订系统"></a>会议室预订系统</h6><p>假设要求同一时间、同一会议室不能预订两次。当有人要预订时，先检查是否有冲突的预订，如果没有，则提交申请：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"><span class="comment">-- Check for any existing bookings that overlap with the period of noon-1pm</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> bookings</span><br><span class="line">    <span class="keyword">WHERE</span> room_id <span class="operator">=</span> <span class="number">123</span> <span class="keyword">AND</span> end_time <span class="operator">&gt;</span> <span class="string">&#x27;2015-01-01 12:00&#x27;</span> <span class="keyword">AND</span> start_time <span class="operator">&lt;</span> <span class="string">&#x27;2015-01-01 13:00&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- If the previous query returned zero:</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> bookings (room_id, start_time, end_time, user_id) </span><br><span class="line">	<span class="keyword">VALUES</span> (<span class="number">123</span>, <span class="string">&#x27;2015-01-01 12:00&#x27;</span>, <span class="string">&#x27;2015-01-01 13:00&#x27;</span>, <span class="number">666</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>快照级别隔离无法阻止并发用户预订同一个会议室。为保证预订不会产生冲突，需要可串行化的隔离。</p>
<h6 id="声明一个用户名"><a href="#声明一个用户名" class="headerlink" title="声明一个用户名"></a>声明一个用户名</h6><p>网站要求每个用户有唯一的用户名，两个用户可能同时尝试创建相同的用户名。可以采用事务的方式，先来检查名称是否被使用，如果没有，则使用该名称创建胀户。但和之前的例子类似，在快照级别隔离下这是不安全的。不过，对于该例子， 一个简单的方案是采用唯一性约束。</p>
<p>上述写倾斜的例子都遵循以下类似的模式：</p>
<ol>
<li>首先用SELECT查询所有满足条件的行。</li>
<li>根据查询的结果，应用层代码决定下一步的操作（可能继续，或报告错误并中止）。</li>
<li>如果应用继续执行，它发起数据库写入（INSERT，UPDATE或DELETE）并提交事务。而<font color=red>这个写操作会改变步骤2做出决定的前提条件</font>。即如果提交写入之后再重复执行步骤1的SELECT查询，会返回完全不同的结果。</li>
</ol>
<p>上述步骤可能有不同的执行顺序，例如，可以先写入，然后是SELECT查询，最后根据查询来决定是否提交或者放弃。</p>
<p>这种<font color=red>在一个事务中的写入改变了另一个事务查询结果的现象，称为幻读</font>。快照级别隔离可以避免只读查询时的幻读，但是对于上面所讨论那些读写事务，它无法解决写倾斜问题。</p>
<h5 id="实体化冲突"><a href="#实体化冲突" class="headerlink" title="实体化冲突"></a>实体化冲突</h5><p>如果问题的关键是查询结果中没有对象（空）时可以加锁，可以<font color=red>人为引入一些可加锁的对象</font>。例如会议室预订的例子，构造一个时间房间表，表的每一行对应特定时间段（例如最小15分钟间隔）的特定房间。提前对接下来的6个月，创建好所有可能的房间与时间的组合。</p>
<p>现在，预订事务可以查询并锁定（SELECT FOR UPDATE）表中与查询房间和时间段所对应的行。加锁后，即可检查是否有重叠，然后像之前一样插入新的预订。注意这种附加表格不存储预订相关信息，仅用于方便加锁，防止同一房间和时间段内的重复预订。</p>
<p>这种方法称为实体化冲突（或物化冲突），它把幻读问题转变为针对数据库中一组具体行的锁冲突问题。然而，弄清楚如何实体化也有挑战性，实现也易出错，这种把一个并发控制机制降级为数据模型的思路总是不够优雅。出于这些原因，除非万不得已，<font color=red>不推荐采用实体化冲突。在大多数情况下，采用可串行化隔离方案更为可行。</font></p>
<h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><p>可串行化隔离通常被认为是最强的隔离级别。它保证<font color=red>即使事务并行执行，但最终的结果与每次一个串行执行结果相同</font>。这表示，若事务在单独运行时表现正确，那它们在并发运行时结果仍然正确，即可以防止所有可能的竞争条件。</p>
<p>如果串行化隔离比其他各种弱隔离级别好得多，为什么没有广泛使用呢？要回答该问题，需要看看可串行化究竟是什么，以及如何执行。目前大多数提供可串行化的数据库都使用了以下三种技术之一。</p>
<h4 id="实际串行执行"><a href="#实际串行执行" class="headerlink" title="实际串行执行"></a>实际串行执行</h4><p>解决并发问题最直接的方法是避免并发：在一个线程上按序每次只执行一个事务。其隔离级别一定是严格串行化的。</p>
<p>Redis和Datomic等采用串行方式执行事务。单线程执行有时可能比支持并发的系统效率更高，尤其是可以避免锁开销。但是，其<font color=red>吞吐量上限是单个CPU核的吞吐量</font>。为充分利用单线程，相比于传统形式，事务也需要<font color=red>做出相应调整，以避免正在执行的事务因效率太低从而影响后面排队的事务</font>。</p>
<h5 id="采用存储过程封装事务"><a href="#采用存储过程封装事务" class="headerlink" title="采用存储过程封装事务"></a>采用存储过程封装事务</h5><p>在数据库发展早期阶段，人们试图将数据库事务设计成为包含整个用户交互流程。如果整个交互流程都从属于一个事务，那么就可以方便地原子化执行。</p>
<p>但人的交互引入的延迟远大于CPU时钟周期甚至IO延迟，因此OLTP型数据库多会避免在单个事务中包含与人的交互，以求单个事务能够较快的执行结束。因此，单线程串行事务系统不允许交互式的多语句事务。<font color=red>用户需要将多语句封装为存储过程一次性提交给数据库</font>。如果数据都在内存中，则存储过程可以被快速的执行，而无需等待网络或磁盘IO。</p>
<h5 id="存储过程的优缺点"><a href="#存储过程的优缺点" class="headerlink" title="存储过程的优缺点"></a>存储过程的优缺点</h5><p>存储过程从1999年就进了SQL标准（SQL&#x2F;PSM），但由于种种原因，一直为人所诟病：</p>
<ol>
<li>数据库厂商都有自己的存储过程语言（Oracle有PL&#x2F;SQL，PostgreSQL有PL&#x2F;pgSQL等），且语法陈旧，迭代缓慢。</li>
<li>相比本地应用代码，存储过程运行在数据库服务器中，难以调试、测试和监控。</li>
<li>数据库通常对性能表现更敏感，一个写的不好的存储过程可能会拖累整个数据库的执行。</li>
</ol>
<p>现代的存储过程直接放弃了PL&#x2F;SQL，转而使用通用编程语言：VoltDB使用Java或Groovy，而Redis使用Lua。从而在某种程度上部分克服上述缺点。</p>
<p>对于内存数据库的单线程事务，使用存储过程可以获得不错的吞吐。因为：内存数据库和存储过程避免了IO；单线程避免了锁开销。</p>
<h5 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h5><p>串行执行所有事务使得并发控制更加简单，但是数据库的吞吐量被限制在单机单个CPU核。虽然只读事务可以在单独的快照上执行，但对于高写入需求的应用程序而言，单线程事务处理很容易成为严重的瓶颈。</p>
<p>为了扩展到多个CPU核和多节点，可以对数据进行分区。如果能找到一个方法来对数据集进行分区，<font font color=red>使得每个事务只在单个分区内读写数据，这样每个分区都可以有自己的事务处理线程且独立运行</font>。此时为每个CPU核分配一个分区，则数据库的总体事务吞吐量可以达到与CPU核的数量成线性比例关系。</p>
<p>对于跨分区的事务，数据库必须在涉及的所有分区之间协调事务。存储过程需要跨越所有分区加锁执行，以确保整个系统的可串行化。由于跨分区事务具有额外的协调开销，其性能比单分区内要慢得多。</p>
<p><font color=red>事务是否能只在单分区上执行很大程度上取决于应用层的数据结构。简单的键值数据比较容易切分，而带有多个二级索引的数据则需要大量的跨区协调，因此不太合适。</font></p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>某些特定场景下，对事务进行真正物理上的串行执行，已经成为一种可串行化隔离级别的实现方案。这些约束包括：</p>
<ul>
<li>事务必须简短而高效，否则一个缓慢的事务会影响到所有其他事务的执行性能。</li>
<li>活跃数据能全部装入内存，沉寂数据可以放在磁盘。总之，需要最少化 IO，以保证所有事务能够快速的执行。</li>
<li>单核 CPU 能够处理所有写入吞吐，或者，能够将事务局限在单个分区，不需要跨分区协调。</li>
<li>只允许有限的跨分区事务。</li>
</ul>
<h4 id="两阶段加锁"><a href="#两阶段加锁" class="headerlink" title="两阶段加锁"></a>两阶段加锁</h4><p>近三十年来，可以说数据库只有一种被广泛使用的串行化算法，即两阶段加锁（two-phase locking, 2PL）。</p>
<p>两阶段加锁方法，多个事务可同时读取同一对象，但只要出现任何写操作（包括修改或删除），则必须加锁以独占访问：</p>
<ul>
<li>若事务A已读取了对象，此时事务B想要写入该对象，那B必须等A提交或中止才能继续。以确保B不会在事务A执行的过程中间去修改对象。</li>
<li>若事务A已修改了对象，此时事务B想要读取该对象，则必须等到A提交或中止后才能继续。对于2PL，不会出现读到旧值的情况（参考图7-1的示例）。</li>
</ul>
<p>因此2PL不仅在并发写操作之间互斥，读取和修改间也互斥。快照级别隔离的特点“读写互不干扰” 准确点明了它和两阶段加锁的关键区别。另一方面，<font color=red>因2PL提供了串行化，所以它可防止前面讨论的所有竞争条件，包括更新丢失和写倾斜。</font></p>
<h5 id="实现两阶段加锁"><a href="#实现两阶段加锁" class="headerlink" title="实现两阶段加锁"></a>实现两阶段加锁</h5><p>目前，2PL已经用于MySQL(InnoDB)和SQL Server 中的“可串行化隔离”。</p>
<p>数据库的每个对象都有一个读写锁来隔离读写操作。即锁可以处于共享模式或独占模式。基本用法如下：</p>
<ul>
<li>如果事务要读对象，必须先以共享模式获得锁。可以有多个事务同时获得一个对象的共享锁，但如果某个事务已经获得了对象的独占锁，则所有其他事务必须等待。</li>
<li>如果事务要修改对象，必须以独占模式获取锁。不允许多个事务同时持有该锁（包括共享或独占模式），换言之，如果对象上已被加锁，则修改事务必须等待。</li>
<li>如果事务首先读取对象，然后尝试写入对象，则需要<font color=red>将共享锁升级为独占锁</font>。升级锁的流程等价于直接获得独占锁。</li>
<li>事务获得锁之后， <font color=red>一直持有锁直到事务结束</font>（包括提交或中止）。这也是名字“两阶段”的来由，在第一阶段即事务执行之前要获取锁，第二阶段（即事务结束时）则释放锁。</li>
</ul>
<p>使用这么多的锁机制，很容易出现死锁。数据库系统会自动检测事务间的死锁情况，并强行中止其中一个，这样另一个可继续执行。而被中止的事务需由应用层重试。</p>
<h5 id="两阶段加锁的性能"><a href="#两阶段加锁的性能" class="headerlink" title="两阶段加锁的性能"></a>两阶段加锁的性能</h5><p>两阶段加锁的主要缺点，或者说自1970年以来并不被所有人接纳的主要原因在于性能：其事务吞吐量和查询响应时间相比于其他弱隔离级别下降非常多。部分原因在于锁的获取和释放本身的开销，但更重要的是其降低了事务的并发性。</p>
<p>传统关系数据库并不限制事务的执行时间，结合2PL，结果就是，当一事务还需等待另一事务时，最终的等待时间几乎没有上限。一旦出现多个事务同时访问同一对象，会形成一个等待队列，事务须等待队列前面其他事务完成之后才能继续。</p>
<p>因此， <font color=red>2PL模式下数据库的访问延迟有非常大的不确定性</font>，如果应用需要稳定如一的性能，这种不确定性就是致命的。</p>
<p>同样基于加锁方式的读已提交隔离也可能发生死锁，然而在2PL下，死锁可能更为频繁。因而导致另一性能问题，即如果事务由于死锁而被强行中止，应用层就必须重试，若死锁过于频繁，则最后的性能和效率必然大打折扣。</p>
<h5 id="谓词锁"><a href="#谓词锁" class="headerlink" title="谓词锁"></a>谓词锁</h5><p>对于加锁，我们还忽略了“写倾斜与幻读”问题，即一个事务改变另一个事务的查询结果。可串行化隔离也必须防止幻读问题。以会议室预订为例，若事务查询某时间段内一个房间的预订情况， 则另一事务不能同时插入或更新同一时间段内该房间的预订情况，但它可以修改其他房间的预订情况，或者在不影响当前查询的情况下，修改该房间的其他时间段预订。</p>
<p>如何实现呢？技术上讲，需要引入一种<font color=red>谓词锁（或者属性谓词锁）</font>。它的作用类似于之前描述的共享&#x2F;独占锁， 区别在于，它不属于某个特定的对象（如表的某一行），而是作用于满足某些搜索条件的所有查询对象，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> bookings</span><br><span class="line"><span class="keyword">WHERE</span> room_id <span class="operator">=</span> <span class="number">123</span> <span class="keyword">AND</span></span><br><span class="line">      end_time <span class="operator">&gt;</span> <span class="string">&#x27;2018-01-01 12:00&#x27;</span> <span class="keyword">AND</span> start_time <span class="operator">&lt;</span> <span class="string">&#x27;2018-01-01 13:00&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>谓词锁会限制如下访问：</p>
<ul>
<li>如果事务A想要读取某些满足匹配条件的对象，例如采用SELECT查询，它必须以共享模式<font color=red>获得查询条件的谓词锁。</font>如果另一事务B正持有任何一个匹配对象的互斥锁，那A必须等B释放锁之后才能继续执行查询。</li>
<li>如果事务A要插入、更新或删除任何对象，则必须先检查所有旧值和新值是否与现有的任何谓词锁冲突。如果事务B 持有这样的谓词锁，那A必须等到B 完成提交（或中止）后才能继续。</li>
</ul>
<p>这里的关键在于，<font color=red>谓词锁可以保护数据库中那些尚不存在但可能马上会被插入的对象</font>（幻读）。将两阶段加锁与谓词锁结合使用，数据库可以防止所有形式的写倾斜以及其他竞争条件，隔离变得真正可串行化。</p>
<h5 id="索引区间锁"><a href="#索引区间锁" class="headerlink" title="索引区间锁"></a>索引区间锁</h5><p>谓词锁性能不佳，因此大多数使用2PL的数据库实际上实现的是索引区间锁，本质上它是对谓词锁的简化。</p>
<p>简化谓词锁的方式是<font color=red>将其保护的对象扩大化</font>，这肯定是安全的。例如，若谓词锁保护的查询条件是：房间123，时间段是中午至下午1点。则可以通过扩大时间段来简化，即保护123房间的所有时间段；或扩大房间，即保护中午至下午1点之间的所有房间。这样，任何与原始谓词锁冲突的操作肯定也和近似之后的区间锁相冲突。</p>
<p>对于房间预订数据库，通常会在room_id列上创建索引，和&#x2F;或在start_time和end_time上有索引（否则前面的查询在大型数据库上会很慢）：</p>
<ul>
<li>假设索引在room_id上，数据库使用此索引查找123号房间的当前预订情况。现在数据库可以简单地将共享锁附加到此索引条目，表明事务已搜索了123号房间的所有时间段预订。</li>
<li>或者，如果数据库使用基于时间的索引来查找预订，可以将共享锁附加到该索引中的一系列值，表示事务已经搜索了该时间段内的所有值。</li>
</ul>
<p>无论哪种方式，查询条件的近似值都附加到某个索引上。如果另一事务想插入、更新或删除同一房间和&#x2F;或重叠时间段的预订，肯定需更新这些索引，一定会与共享锁冲突，会自动等待直到共享锁释放。这就有效防止了写倾斜和幻读问题。</p>
<p>的确，索引区间锁不像谓词锁那么精确（会锁定更大范围的对象，超出了串行化所要求的部分），但由于开销低得多，可以认为是一种很好的折衷方案。</p>
<p>如果没有合适的索引可以施加区间锁，数据库可以回退到对整个表施加共享锁。这种方式的性能肯定不好，它甚至会阻止所有其他事务的写操作，但的确可以保证安全性。</p>
<h4 id="可串行化的快照隔离"><a href="#可串行化的快照隔离" class="headerlink" title="可串行化的快照隔离"></a>可串行化的快照隔离</h4><p>2008 年，Michael Cahill 在其博士论文中提出了一种新型的可串行化实现方案：可串行的快照隔离（SSI，serializable snapshot isolation）。<font color=red>它提供了完整的可串行性保证，而性能相比于快照隔离损失很小。</font></p>
<p>无论单机数据库（PostgreSQL 9.1+ 的可串行化隔离级别）和分布式数据库（FoundationDB 使用了类似算法）都有SSI 的身影。相比其他方式，SSI还相对不太成熟，但其表现出的性能优势，使其隐隐然有成为可串行化默认实现的趋势。</p>
<h5 id="悲观与乐观的并发控制"><a href="#悲观与乐观的并发控制" class="headerlink" title="悲观与乐观的并发控制"></a>悲观与乐观的并发控制</h5><p>两阶段加锁是一种典型的悲观并发控制机制。它基于这样的设计原则： 如果某些操作可能出错（例如与其他并发事务发生了锁冲突），那么直接放弃，采用等待方式直到绝对安全。这和多线程编程中互斥锁是一致的。</p>
<p>相比之下，可串行化的快照隔离是一种<font color=red>乐观并发控制</font>。如果可能发生潜在冲突，事务继续执行。当事务提交时（只有可串行化的事务被允许提交），数据库检查是否确实发生了冲突（违反了隔离性原则），若是，中止事务并接下来重试。</p>
<p>乐观并发控制其实是一个古老的想法，其优缺点已经争论了很长时间：如果冲突很多（许多事务试图访问相同的对象），则性能不佳，大量的事务必须中止。如果系统已接近其最大吞吐量，反复重试事务会使系统性能变得更差。但如果系统还有足够的性能提升空间，且事务之间的竞争不大，乐观并发控制会比悲观方式高效很多。</p>
<p>SSI基于快照隔离，即事务中的所有读操作都是基于数据库的一致性快照。<font color=red>在快照隔离的基础上，SSI新增加了相关算法来检测写入之间的串行化冲突从而决定中止哪些事务。</font></p>
<h5 id="基于过期的条件做决定"><a href="#基于过期的条件做决定" class="headerlink" title="基于过期的条件做决定"></a>基于过期的条件做决定</h5><p>讨论写倾斜时，介绍了这样一种场景： 事务先查询某些数据，根据查询结果决定后续操作，如修改数据。<font color=red>在快照隔离情况下，数据可能在查询期间就已被其他事务修改</font>，导致原事务在提交时决策的依据信息已发生变化。事务开始时条件成立，如“目前有两名医生值班”，而当事务要提交时，数据可能已经发生改变，条件已不再成立。</p>
<p>当应用程序查询时（如“当前有多少医生在值班”），数据库本身无法预知应用层如何使用这些查询结果。安全起见，<font color=red>数据库假定对查询结果（决策的前提条件）的任何变化都应使写事务失效</font>。换言之，查询与写事务之间可能存在因果依赖关系。为提供可串行化的隔离，数据库须检测事务是否会修改其他事务的查询结果，并在此情况下中止写事务。</p>
<p>数据库如何知道查询结果是否发生了改变呢？可以分以下两种情况：</p>
<ul>
<li>读取是否作用于一个（即将）过期的MVCC对象（<font color=red>读取之前已经有未提交的写入</font>）。</li>
<li>检查写入是否影响即将完成的读取（<font color=red>读取之后，又有新的写入</font>）。</li>
</ul>
<h4 id="检测是否读取了过期的MVCC对象"><a href="#检测是否读取了过期的MVCC对象" class="headerlink" title="检测是否读取了过期的MVCC对象"></a>检测是否读取了过期的MVCC对象</h4><p>快照隔离通常采用多版本并发控制技术（MVCC）来实现。当事务从MVCC数据库一致性快照读取时，它会忽略那些在创建快照时尚未提交的事务写入。如图7-10中，事务42 （修改Alice的值班状态）未提交，因此事务43中查询到Alice的on_call是true。事务43提交时，事务42已完成提交。换言之，<font color=red>快照读取时被忽略的写入已经生效，且直接导致事务43做决定的前提已不再成立。</font></p>
<img src="/img/07事务/ch07-fig10.png" alt="Untitled" style="zoom: 67%;" />

<p>为防止这种异常，数据库需跟踪那些由于MVCC可见性规则而被忽略的写操作。当事务提交时，数据库会检查是否存在一些当初被忽略的写操作现在已经完成了提交，如果是则必须中止当前事务。</p>
<p>为什么要等到提交：当检测到读旧值，为何不立即中止事务43呢？首先，若事务43是个只读事务，无任何写倾斜风险，就无需中止；而事务43读数据库时，数据库还不知道事务是否稍后有任何写操作。此外，事务提交时，可能事务42发生了中止或者还处于未提交状态，因此读取的并非是过期值。</p>
<p>总结：<font color=red>读取时，检测写读冲突，延到提交时，看有冲突的写入是否已提交。</font></p>
<h5 id="检测写是否影晌了之前的读"><a href="#检测写是否影晌了之前的读" class="headerlink" title="检测写是否影晌了之前的读"></a>检测写是否影晌了之前的读</h5><p>第二种要考虑的情况是，在读取数据之后，另一个事务修改了数据。如图7-11所示。</p>
<img src="/img/07事务/ch07-fig11.png" alt="Untitled" style="zoom:33%;" />

<p>“两阶段加锁”中讨论了索引区间锁，它可以锁定与某个查询条件匹配的所有行，例如<code>WHERE shift_id = 1234</code>。这里使用了类似的技术，只有一点差异：SSI锁不会阻塞其他事务。</p>
<p>图7-11中，事务42和事务43都在查询轮班1234期间的值班医生。如果在shift_id上建有索引，数据库可以<font color=red>通过索引条目1234来记录事务42和事务43都查询了相同的结果。</font>如果没有索引，�</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag"># 分布式</a>
              <a href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/" rel="tag"># 一致性</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/20/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/06%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA/" rel="prev" title="DDIA笔记-06数据分区">
      <i class="fa fa-chevron-left"></i> DDIA笔记-06数据分区
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.</span> <span class="nav-text">深入理解事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ACID%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">ACID的含义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">1.1.1.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">1.1.2.</span> <span class="nav-text">一致性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="nav-number">1.1.3.</span> <span class="nav-text">隔离性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7"><span class="nav-number">1.1.4.</span> <span class="nav-text">持久性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%A4%9A%E5%AF%B9%E8%B1%A1%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.</span> <span class="nav-text">单对象与多对象事务操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%B1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">2.</span> <span class="nav-text">弱隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4"><span class="nav-number">2.1.</span> <span class="nav-text">读已提交</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B2%E6%AD%A2%E8%84%8F%E8%AF%BB"><span class="nav-number">2.1.1.</span> <span class="nav-text">防止脏读</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B2%E6%AD%A2%E8%84%8F%E5%86%99"><span class="nav-number">2.1.2.</span> <span class="nav-text">防止脏写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4"><span class="nav-number">2.1.3.</span> <span class="nav-text">实现读已提交</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E7%85%A7%E7%BA%A7%E5%88%AB%E9%9A%94%E7%A6%BB%E4%B8%8E%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="nav-number">2.2.</span> <span class="nav-text">快照级别隔离与可重复读</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%BF%AB%E7%85%A7%E7%BA%A7%E5%88%AB%E9%9A%94%E7%A6%BB"><span class="nav-number">2.2.1.</span> <span class="nav-text">实现快照级别隔离</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%BF%AB%E7%85%A7%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E8%A7%84%E5%88%99"><span class="nav-number">2.2.2.</span> <span class="nav-text">一致性快照的可见性规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%BF%AB%E7%85%A7%E7%BA%A7%E5%88%AB%E9%9A%94%E7%A6%BB"><span class="nav-number">2.2.3.</span> <span class="nav-text">索引与快照级别隔离</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E4%B8%8E%E5%91%BD%E5%90%8D%E6%B7%B7%E6%B7%86"><span class="nav-number">2.2.4.</span> <span class="nav-text">可重复读与命名混淆</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B2%E6%AD%A2%E6%9B%B4%E6%96%B0%E4%B8%A2%E5%A4%B1"><span class="nav-number">2.3.</span> <span class="nav-text">防止更新丢失</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E5%86%99%E6%93%8D%E4%BD%9C"><span class="nav-number">2.3.1.</span> <span class="nav-text">原子写操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E5%8A%A0%E9%94%81"><span class="nav-number">2.3.2.</span> <span class="nav-text">显式加锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E6%9B%B4%E6%96%B0%E4%B8%A2%E5%A4%B1"><span class="nav-number">2.3.3.</span> <span class="nav-text">自动检测更新丢失</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%AF%94%E8%BE%83%E5%92%8C%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.3.4.</span> <span class="nav-text">原子比较和设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E5%89%AF%E6%9C%AC%E5%92%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3"><span class="nav-number">2.3.5.</span> <span class="nav-text">多副本和冲突解决</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E5%80%BE%E6%96%9C%E4%B8%8E%E5%B9%BB%E8%AF%BB"><span class="nav-number">2.4.</span> <span class="nav-text">写倾斜与幻读</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%86%99%E5%80%BE%E6%96%9C"><span class="nav-number">2.4.1.</span> <span class="nav-text">定义写倾斜</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E5%86%99%E5%80%BE%E6%96%9C%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">2.4.2.</span> <span class="nav-text">更多写倾斜的例子</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BC%9A%E8%AE%AE%E5%AE%A4%E9%A2%84%E8%AE%A2%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">会议室预订系统</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E5%90%8D"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">声明一个用户名</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E4%BD%93%E5%8C%96%E5%86%B2%E7%AA%81"><span class="nav-number">2.4.3.</span> <span class="nav-text">实体化冲突</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E8%A1%8C%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">串行化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E4%B8%B2%E8%A1%8C%E6%89%A7%E8%A1%8C"><span class="nav-number">3.1.</span> <span class="nav-text">实际串行执行</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%87%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%B0%81%E8%A3%85%E4%BA%8B%E5%8A%A1"><span class="nav-number">3.1.1.</span> <span class="nav-text">采用存储过程封装事务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.1.2.</span> <span class="nav-text">存储过程的优缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%8C%BA"><span class="nav-number">3.1.3.</span> <span class="nav-text">分区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">3.1.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%8A%A0%E9%94%81"><span class="nav-number">3.2.</span> <span class="nav-text">两阶段加锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%8A%A0%E9%94%81"><span class="nav-number">3.2.1.</span> <span class="nav-text">实现两阶段加锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%8A%A0%E9%94%81%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-number">3.2.2.</span> <span class="nav-text">两阶段加锁的性能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%93%E8%AF%8D%E9%94%81"><span class="nav-number">3.2.3.</span> <span class="nav-text">谓词锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%8C%BA%E9%97%B4%E9%94%81"><span class="nav-number">3.2.4.</span> <span class="nav-text">索引区间锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%E7%9A%84%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB"><span class="nav-number">3.3.</span> <span class="nav-text">可串行化的快照隔离</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E4%B8%8E%E4%B9%90%E8%A7%82%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-number">3.3.1.</span> <span class="nav-text">悲观与乐观的并发控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%BF%87%E6%9C%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%E5%81%9A%E5%86%B3%E5%AE%9A"><span class="nav-number">3.3.2.</span> <span class="nav-text">基于过期的条件做决定</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E8%AF%BB%E5%8F%96%E4%BA%86%E8%BF%87%E6%9C%9F%E7%9A%84MVCC%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.4.</span> <span class="nav-text">检测是否读取了过期的MVCC对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E5%86%99%E6%98%AF%E5%90%A6%E5%BD%B1%E6%99%8C%E4%BA%86%E4%B9%8B%E5%89%8D%E7%9A%84%E8%AF%BB"><span class="nav-number">3.4.1.</span> <span class="nav-text">检测写是否影晌了之前的读</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="gqtc"
      src="/images/panda.gif">
  <p class="site-author-name" itemprop="name">gqtc</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">gqtc</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'DOtutT1RryAIysn71vbzynQy-gzGzoHsz',
      appKey     : 'KxMi4qDudMqAUjo5HbMTp5Ht',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
