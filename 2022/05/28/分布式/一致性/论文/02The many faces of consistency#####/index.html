<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/function%20()%20%7B%0A%20%20%20%20%20%20for%20(var%20_len2%20=%20arguments.length,%20args%20=%20new%20Array(_len2),%20_key2%20=%200;%20_key2%20%3C%20_len2;%20_key2++)%20%7B%0A%20%20%20%20%20%20%20%20args%5B_key2%5D%20=%20arguments%5B_key2%5D;%0A%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20return%20obj%5Bval%5D.apply(obj,%20args);%0A%20%20%20%20%7D">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","width":160,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一致性的概念存在于计算机科学中的各种学科中，比如分布式系统、数据库系统，计算机体系结构等。然而在这些学科中，一致性可能表示的是完全不同的事情。本文中我们识别出一致性的两大类型：状态一致性和操作一致性，它们在含义和应用范围上有根本的不同。本文中我们会通过每个学科中的多个示例来解释这两种一致性类型。">
<meta property="og:type" content="article">
<meta property="og:title" content="The many faces of consistency">
<meta property="og:url" content="http://example.com/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7/%E8%AE%BA%E6%96%87/02The%20many%20faces%20of%20consistency#####/index.html">
<meta property="og:site_name" content="gqtc&#39;s blog">
<meta property="og:description" content="一致性的概念存在于计算机科学中的各种学科中，比如分布式系统、数据库系统，计算机体系结构等。然而在这些学科中，一致性可能表示的是完全不同的事情。本文中我们识别出一致性的两大类型：状态一致性和操作一致性，它们在含义和应用范围上有根本的不同。本文中我们会通过每个学科中的多个示例来解释这两种一致性类型。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-05-27T16:00:00.000Z">
<meta property="article:modified_time" content="2022-06-29T05:44:52.311Z">
<meta property="article:author" content="gqtc">
<meta property="article:tag" content="分布式">
<meta property="article:tag" content="一致性">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7/%E8%AE%BA%E6%96%87/02The%20many%20faces%20of%20consistency#####/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>The many faces of consistency | gqtc's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">gqtc's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7/%E8%AE%BA%E6%96%87/02The%20many%20faces%20of%20consistency#####/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/panda.gif">
      <meta itemprop="name" content="gqtc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gqtc's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          The many faces of consistency
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-28 00:00:00" itemprop="dateCreated datePublished" datetime="2022-05-28T00:00:00+08:00">2022-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-29 13:44:52" itemprop="dateModified" datetime="2022-06-29T13:44:52+08:00">2022-06-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7/" itemprop="url" rel="index"><span itemprop="name">一致性</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7/%E8%AE%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">论文</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7/%E8%AE%BA%E6%96%87/02The%20many%20faces%20of%20consistency#####/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7/%E8%AE%BA%E6%96%87/02The%20many%20faces%20of%20consistency#####/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><font color=red>一致性的概念存在</font>于计算机科学中的各种学科中，比如<font color=red>分布式系统、数据库系统，计算机体系结构</font>等。然而在这些学科中，一致性可能表示的是完全不同的事情。本文中我们识别出一致性的两大类型：状态一致性和操作一致性，它们在含义和应用范围上有根本的不同。本文中我们会通过每个学科中的多个示例来解释这两种一致性类型。</p>
<span id="more"></span>
<p>The notion of consistency is used across different computer science disciplines from distributed systems to database systems to computer architecture. It turns out that consistency can mean quite different things across these disciplines, depending on who uses it and in what context it appears. We identify two broad types of consistency, state consistency and operation consistency, which differ fundamentally in meaning and scope. We explain how these types map to the many examples of consistency in each discipline.</p>
<h3 id="1-Introduction-引言"><a href="#1-Introduction-引言" class="headerlink" title="1 Introduction     引言"></a>1 Introduction     引言</h3><p>在涉及<font color=red>共享和多数据副本</font>的计算机系统中，一致性是个重要的考虑因素。早期的计算系统只有私有数据，而随着计算机从计算机器发展到信息交换工具，共享数据变得越来越普遍。从分布式系统到数据库系统再到多处理器系统，共享数据出现在许多类型的系统中。比如在分布式系统中，跨网络的文件共享、DNS条目、Key-value系统中的数据块、系统元数据等都需要共享数据；在数据库系统中，用户需要共享包含账户信息、产品描述、航班预订和座位分配的表；在计算机系统内部，多CPU核心需要共享cache line和物理内存。</p>
<p>Consistency is an important consideration in computer systems that share and replicate data. Whereas early computing systems had private data exclusively, shared data has become increasingly common as computers have evolved from calculating machines to tools of information exchange. Shared data occurs in many types of systems, from distributed systems to database systems to multiprocessor systems. For example, in distributed systems, users across the network share files (e.g., source code), network names (e.g., DNS entries), data blobs (e.g., images in a key-value store), or system metadata (e.g., configuration information). In database systems, users share tables containing account information, product descriptions, flight bookings, and seat assignments. Within a computer, processor cores share cache lines and physical memory.</p>
<p>除了共享，计算机系统越来越多地需要在组件间复制数据。分布式系统中，每个节点可能都持有共享文件、DNS条目、数据块或系统元数据的本地副本。这些副本称为缓存，可以提高系统的性能；数据库系统中，会复制行或表以提高速度或进行容错；在计算机系统内，内存的部分内容在缓存层次结构（L1、L2、L3缓存）中的不同点进行复制，这也是为了提高速度。我们使用“副本”一词广义的表示系统维护的数据的任何副本。</p>
<p>In addition to sharing, computer systems increasingly replicate data within and across components. In distributed systems, each site may hold a local replica of files, network names, blobs, or system metadata—these replicas, called caches, increase performance of the system. Database systems also replicate rows or tables for speed or to tolerate disasters. Within a computer, parts of memory are replicated at various points in the cache hierarchy (L1、L2、L3 caches), again for speed. We use the term replica broadly to mean any copies of the data maintained by the system.</p>
<p>在所有这些系统中，数据共享和复制都涉及到一个<font color=red>基本问题：如果一个Client修改了一些数据项，同一时间，另一个Client在不同的副本上，读取或者修改了相同的数据项，会发生什么？</font></p>
<p>In all these systems, data sharing and replication raise a fundamental question: what should happen if a client modifies some data items and simultaneously, or within a short time, another client reads or modifies the same items, possibly at a different replica?</p>
<p>这个问题没有适用所有场景的标准答案。一致性属性通过限制数据的变化方式或Client在每种情况下可以观察到的内容来控制可能的结果。比如，在DNS系统中，对域名的修改可能数小时内都是不可见的，而唯一能保证的是，最终总会看到更新—-这是最终一致性的例子。但是对于航班订座系统来说，更新必须是即时的，互斥的，这样才能确保两个乘客不会订到相同的座位—-这是序列化保证的强一致性的例子。还有其他一些一致性属性，包括因果一致性（causal consistency）、读我所写（read-my-writes）、有界延迟一致性（bounded staleness）、持续一致性（continuous consistency）、释放一致性（release consistency）、fork一致性（fork consistency）、epsilon序列化性（epsilon serializability）等等。</p>
<p>This question does not have a single answer that is right in every context. A consistency property governs the possible outcomes by limiting how data can change or what clients can observe in each case. For example, with DNS, a change to a domain may not be visible for hours; the only guarantee is that updates will be seen eventually—an example of a property called eventual consistency [23]. But with flight seat assignments, updates must be immediate and mutually exclusive, to ensure that no two passengers receive the same seat—an example of a strong type of consistency provided by serializability [5]. Other consistency properties include causal consistency [13], read-my-writes [21], bounded staleness [1], continuous consistency [1, 25], release consistency [10], fork consistency [16], epsilon serializability [18], and more.</p>
<p>一致性很重要，因为开发者必须能理解上面那个基本问题的答案。特别是当与系统交互的Client不是人类，而是其他计算机程序时，开发者就必须能编码应对所有可能的状况。</p>
<p>Consistency is important because developers must understand the answer to the above fundamental question. This is especially true when the clients interacting with the system are not humans but other computer programs that must be coded to deal with all possible outcomes.</p>
<p>本文我们研究了分布式系统、数据库系统和计算机体系结构这三种计算机学科如何使用一致性的诸多例子。我们发现这些学科对于一致性的使用存在很大差异。为了更清晰的解释一致性，我们识别出了两种根本不同的一致性类型：<font color=red>状态一致性和操作一致性。状态一致性关心的是系统状态，建立了不同数据项或是相同数据项的不同副本之间的正确关系的约束。</font>比如，状态一致性可能要求两个副本在更新完成时保存的是相同的值；<font color=red>操作一致性关注的是针对系统的操作，并对它们可能返回的结果建立约束</font>。比如，操作一致性可能要求对文件的读操作能反映出该文件上最近一次写入的内容。状态一致性更容易一些，并且依赖于应用程序，而操作一致性更复杂且不依赖于应用程序。这两种类型的一致性都很重要，在我们看来，社区应该更清楚地将它们区分开来。</p>
<p>In this article, we examine many examples of how consistency is used across three computer science disciplines: distributed systems, database systems, and computer architecture. We find that the use of consistency varies significantly across these disciplines. To bring some clarity, we identify two fundamentally different types of consistency: state consistency and operation consistency. State consistency concerns the state of the system and establishes constraints on the allowable relationships between different data items or different replicas of the same items. For instance, state consistency might require that two replicas store the same value when updates are not outstanding. Operation consistency concerns operations on the system and establishes constraints on what results they may return. For instance, operation consistency might require that a read of a file reflects the contents of the most recent write on that file. State consistency tends to be simpler and application dependent, while operation consistency tends to be more complex and application agnostic. Both types of consistency are important and, in our opinion, our communities should more clearly disentangle them.</p>
<p>虽然本文讨论了不同形式的一致性，但它更关注的是一致性的语义，而非一致性的实现机制。语义指的是系统能提供什么样的一致性属性，而机制指的是系统如何实现来保证这些一致性属性。语义和机制密切相关，但相比较而言，理解语义更重要一些。</p>
<p>While this article discusses different forms of consistency, it focuses on the semantics of consistency rather than the mechanisms of consistency. Semantics refer to what consistency properties the system provides, while mechanisms refer to how the system enforces those properties. Semantics and mechanisms are closely related but it is important to understand the former without needing to understand the latter.</p>
<p>本文的其余部分组织如下。第2章解释本文中使用的抽象系统模型和术语；第3章中介绍这两种一致性类型及其各种实例；第4章中说明了不同的学科如何使用这些一致性类型。</p>
<p>The rest of this article is organized as follows. We first explain the abstract system model and terminology used throughout the article in Section 2. We present the two types of consistency and their various embodiments in Section 3. We indicate how these consistency types occur across different disciplines in Section 4.</p>
<hr>
<h3 id="2-Abstract-model-抽象模型"><a href="#2-Abstract-model-抽象模型" class="headerlink" title="2 Abstract model     抽象模型"></a>2 Abstract model     抽象模型</h3><p>考虑一个系统，其具有多个Client，并且这些Client会向系统提交要执行的操作。Client可能是人类用户、计算机程序或其他与本系统无关的系统。而操作可能包括简单的读、写、读修改写、启动和提交事务、range queries。操作通常作用于数据项，这些数据项可以是数据块、文件、键值对、DNS条目、表中的行、内存等。</p>
<p>We consider a setting with multiple clients that submit operations to be executed by the system. Clients could be human users, computer programs, or other systems that do not concern us. Operations might include simple read and write, read-modify-write, start and commit a transaction, and range queries. Operations typically act on data items, which could be blocks, files, key-value pairs, DNS entries, rows of tables, memory locations, and so on.</p>
<p>系统有一个状态，其中包含了数据项的当前值。某些情况下，我们感兴趣的是Client的缓存，以及其他副本的一致性。这种情况下，缓存和其他副本被视为系统的一部分，而系统状态包含其内容。</p>
<p>The system has a state, which includes the current values of the data items. In some cases, we are interested in the consistency of client caches and other replicas. In these cases, the caches and other replicas are considered to be part of the system and the system state includes their contents.</p>
<p>操作的执行不是瞬间的，它是有起始时间的，从Client提交操作算开始，到Client从系统获得响应时结束。如果操作没有响应，则当系统不再主动处理时，算是操作完成。</p>
<p>An operation execution is not instantaneous; rather, it starts when a client submits the operation, and it finishes when the client obtains its response from the system. If the operation execution returns no response, then it finishes when the system is no longer actively processing it.</p>
<p>操作不同于操作的执行。操作是静态的，系统中的操作相对较少，例如读写操作。另一方面，操作执行是动态的，数量众多。Client可以多次执行相同的操作，但每次的操作执行都是独一无二的。虽然从技术上讲，我们应该将操作与操作执行分开，但当上下文比较清晰时，我们往往会模糊这一区别（例如，我们可能会说读操作完成了，而不是读操作的执行完成了）。</p>
<p>Operations are distinct from operation executions. Operations are static and a system has relatively few of them, such as read and write. Operation executions, on the other hand, are dynamic and numerous. A client can execute the same operation many times, but each operation execution is unique. While technically we should separate operations from operation executions, we often blur the distinction when it is clear from the context (e.g., we might say that the read operation finishes, rather than the execution of the read operation finishes).</p>
<hr>
<h3 id="3-Two-types-of-consistency-两种类型的一致性"><a href="#3-Two-types-of-consistency-两种类型的一致性" class="headerlink" title="3 Two types of consistency     两种类型的一致性"></a>3 Two types of consistency     两种类型的一致性</h3><p>这里我们关心的是，当多个Client同时或者几乎同时并发访问共享和数据副本时会发生什么？一般而言，一致性就是根据应用程序的需求约束操作的允许的结果。现在我们定义两种一致性类型。一种是对状态施加约束，另一种是对操作结果施加约束。</p>
<p>We are interested in what happens when shared and replicated data is accessed concurrently or nearly concurrently by many clients. Generally speaking, consistency places constraints on the allowable outcomes of operations, according to the needs of the application. We now define two broad types of consistency. One places constraints on the state, the other on the results of operations.</p>
<h4 id="3-1-State-consistency-状态一致性"><a href="#3-1-State-consistency-状态一致性" class="headerlink" title="3.1 State consistency     状态一致性"></a>3.1 State consistency     状态一致性</h4><p><font color=red>状态一致性与系统状态有关，它由用户期望的状态（即使存在并发访问和多份数据副本的情况下）满足的属性组成。</font>当数据可能因错误（程序崩溃、位翻转、bug等）被破坏时，状态一致性也适用，但这不是本文的重点。</p>
<p>State consistency pertains to the state of the system; it consists of properties that users expect the state to satisfy despite concurrent access and the existence of multiple replicas. State consistency is also applicable when data can be corrupted by errors (crashes, bit flips, bugs, etc), but this is not the focus of this article. </p>
<p>根据状态属性的表达方式，状态一致性可以分为许多子类型。接下来我们将解释这些子类型。</p>
<p>State consistency can be of many subcategories, based on how the properties of state are expressed. We explain these subcategories next.</p>
<h5 id="3-1-1-Invariants-不变式"><a href="#3-1-1-Invariants-不变式" class="headerlink" title="3.1.1 Invariants     不变式"></a>3.1.1 Invariants     不变式</h5><p>状态一致性最简单的子类型是由不变式定义的，<font color=red>所谓不变式，就是针对状态的一个必须为true的断言。</font>比如，在一个并发程序中，单链表不能包含环；在多核处理器系统中，如果两个CPU核的本地缓存保存的是针对相同内存地址的值，则他们的值必须是相同的；在社交网络中，用户x是用户y的朋友，那y也是x的朋友；在一个照片共享应用中，如果相册中包含了某个图像，那该图像的所有者就是相册。</p>
<p>The simplest subcategory of state consistency is one defined by an invariant—a predicate on the state that must evaluate to true. For instance, in a concurrent program, a singly linked list must not contain cycles. In a multiprocessor system, if the local caches of two processors keep a value for some address, it must be the same value. In a social network, if user x is a friend of user y then y is a friend of x. In a photo sharing application, if a photo album includes an image then the image’s owner is the album.</p>
<p>数据库系统中的两个重要的例子是，<font color=red>唯一性约束和引用完整性</font>。表中某一列上的唯一性约束要求该列中每个值只能出现一次。该属性对于表的主键而言至关重要。</p>
<p>In database systems, two important examples are uniqueness constraints and referential integrity. A uniqueness constraint on a column of a table requires that each value appearing in that column must occur in at most one row. This property is crucial for the primary keys of tables.</p>
<p>引用完整性涉及引用另一个表的键。数据库中经常需要通过在表A的列中包含表B中的键来表示两个表的关系。引用完整性要求表A中保存的键确实是表B中的键。比如，在银行的数据库中，假设有一个账户表，该表中包含一个表示账户所有者的列，即user id，同时，user id是用户表的主键，用户表中记录了用户的详细信息。引用完整性要求账户表中的id必须存在于用户表中。</p>
<p>Referential integrity concerns a table that refers to keys of another table. Databases may store relations between tables by including keys of a table within columns in another table. Referential integrity requires that the included keys are indeed keys in the first table. For instance, in a bank database, suppose that an accounts table includes a column for the account owner, which is a user id; meanwhile, the user id is the primary key in a users table, which has detailed information for each user. A referential integrity constraint requires that user ids in the accounts table must indeed exist in the users table.</p>
<p>基于不变式的状态一致性的另一个例子就是<font color=red>相互一致性</font>，用于使用像主备这样的技术来进行复制的分布式系统中。相互一致性要求没有未完成的更新时，副本要具有相同的状态。在更新期间，副本可能会暂时不一致，因为更新不可能同时应用到所有副本上。</p>
<p>Another example of state consistency based on invariants is mutual consistency, used in distributed systems that are replicated using techniques such as primary-backup [2]. Mutual consistency requires that replicas have the same state when there are no outstanding updates. During updates, replicas may diverge temporarily since the updates are not applied simultaneously at all replicas.</p>
<h5 id="3-1-2-Error-bounds-有界不一致"><a href="#3-1-2-Error-bounds-有界不一致" class="headerlink" title="3.1.2 Error bounds     有界不一致"></a>3.1.2 Error bounds     有界不一致</h5><p>如果状态是数字类型的数据，则一致性属性可以表示为与预期值的最大偏差或误差。比如，两个副本上的值最多可能相差ϵ。在物联网系统中，传感器（如温度计）的报告值与被测实际值的误差在ϵ范围内。此示例将系统状态与世界状态相关联。错误界限最初是在数据库社区中提出的，其基本思想后来又在分布式系统社区中复兴。</p>
<p>If the state contains numerical data, the consistency property could indicate a maximum deviation or error from the expected. For instance, the values at two replicas may diverge by at most ϵ. In an internet-of-things system, the reported value of a sensor, such as a thermometer, must be within ϵ from the actual value being measured. This example relates the state of the system to the state of the world. Error bounds were first proposed within the database community [1] and the basic idea was later revived in the distributed systems community [25].</p>
<h5 id="3-1-3-Limits-on-proportion-of-violations-不一致的比例限制"><a href="#3-1-3-Limits-on-proportion-of-violations-不一致的比例限制" class="headerlink" title="3.1.3 Limits on proportion of violations     不一致的比例限制"></a>3.1.3 Limits on proportion of violations     不一致的比例限制</h5><p>如果系统有很多属性或不变式，那期望所有属性或不变式都成立是不现实的，可以预期有一个很高的比例的属性或不变式是成立的。比如，系统可能需要在百万个用户中仅有一个用户的不变式被破坏。如果系统可以补偿一小部分用户数据的不一致，那这样做是有意义的。</p>
<p>If there are many properties or invariants, it may be unrealistic to expect all of them to hold, but rather just a high percentage. For instance, the system may require that at most one user’s invariants are violated in a pool of a million users; this could make sense if the system can compensate a small fraction of users for inconsistencies in their data.</p>
<h5 id="3-1-4-Importance-一致性等级"><a href="#3-1-4-Importance-一致性等级" class="headerlink" title="3.1.4 Importance     一致性等级"></a>3.1.4 Importance     一致性等级</h5><p>属性或不变式的重要性可以分等级，比如critical, important, advisable, desirable, 或 optional，用户可能希望所有时刻只要critical的属性能够维持就行了。开发者可以采用更昂贵，更高效的机制来保证更重要的不变式。比如，当用户在网站上修改密码时，系统需要确认所有副本上的用户账户中的密码都是一样的之后，再回复用户密码修改成功。这种属性是通过确认所有副本并等待答复来实现的，对于不太重要的属性来说，这是一种过于昂贵的机制。</p>
<p>Properties or invariants may be critical, important, advisable, desirable, or optional, where users expect only the critical properties to hold at all times. Developers can use more expensive and effective mechanisms for the more important invariants. For instance, when a user changes her password at a web site, the system might require all replicas of the user account to have the same password before acknowledging the change to the user. This property is implemented by contacting all replicas and waiting for replies, which can be an overly expensive mechanism for less important properties.</p>
<h5 id="3-1-5-Eventual-invariants-最终不变式"><a href="#3-1-5-Eventual-invariants-最终不变式" class="headerlink" title="3.1.5 Eventual invariants     最终不变式"></a>3.1.5 Eventual invariants     最终不变式</h5><p>不变式可能需要经过一定时间之后才能保持。比如，<font color=red>最终一致性</font>的规则中，每个副本不一定所有时刻都是相同的，只要在停止更新后最终变成一样就行了。这种最终一致性可能是合适的，因为副本可能在后台更新，或者使用一些反熵的机制，其中副本的接收和处理更新可能需要不确定的时间。最终一致性的概念是由分布式系统社区创造，尽管数据库社区之前就提出了在分区期间协调出现分歧的副本的想法。</p>
<p>An invariant may need to hold only after some time has passed. For example, under eventual consistency, replicas need not be the same at all times, as long as they eventually become the same when updates stop occurring. This eventual property is appropriate because replicas may be updated in the background or using some anti-entropy mechanism, where it takes an indeterminate amount of time for a replica to receive and process an update. Eventual consistency was coined by the distributed systems community [23], though the database community previously proposed the idea of reconciling replicas that diverge during partitions [9].</p>
<p>状态一致性仅限于状态上的属性，但许多情况下，Client不太关心状态，而更关心从系统获得的结果。换句话说，重要的是Client在与系统交互时观察到的行为。这些情况需要另一种不同形式的一致性，我们在下面讨论。</p>
<p>State consistency is limited to properties on state, but in many cases clients care less about the state and more about the results that they obtain from the system. In other words, what matters is the behavior that clients observe from interacting with the system. These cases call for a different form of consistency, which we discuss next.</p>
<h4 id="3-2-Operation-consistency-操作一致性"><a href="#3-2-Operation-consistency-操作一致性" class="headerlink" title="3.2 Operation consistency     操作一致性"></a>3.2 Operation consistency     操作一致性</h4><p>操作一致性关注的是Client执行的操作；它由表示操作是否返回可接受结果的属性组成。这些属性会将许多操作的执行联系在一起，就像下面的例子展示的那样。</p>
<p>操作一致性有多种子类型，这些子类型按照不同的方式定义了一致性属性。接下来我们将解释这些子类型。</p>
<p>Operation consistency pertains to the operation executions by clients; it consists of properties that indicate whether operations return acceptable results. These properties can tie together many operation executions, as shown in the examples below.</p>
<p>Operation consistency has subcategories, with different ways to define the consistency property. We explain these subcategories next.</p>
<h5 id="3-2-1-Sequential-equivalence-顺序等价性"><a href="#3-2-1-Sequential-equivalence-顺序等价性" class="headerlink" title="3.2.1 Sequential equivalence     顺序等价性"></a>3.2.1 Sequential equivalence     顺序等价性</h5><p>这种子类型从顺序执行操作（一次执行一个操作，没有并发。<em>个人理解这里的顺序执行就是串行执行</em>）得到的允许的结果的角度，来定义并发执行时允许得到的操作结果。具体而言，需要有一种方式，来执行任何Client子集提交的所有操作，然后将它们还原为一种正确的顺序执行。而具体的还原方式，则取决于特定的一致性属性。从技术角度上讲，所谓正确的顺序执行是跟系统相关的，因此也需要对系统进行指定，但是因过于明显而经常被忽略。</p>
<p>我们现在给出一些顺序等价的例子。</p>
<p>This subcategory defines the permitted operation results of a concurrent execution in terms of the permitted operation results in a sequential execution—one in which operations are executed one at a time, without concurrency. More specifically, there must be a way to take the execution of all operations submitted by any subset of clients, and then reduce them to a sequential execution that is correct. The exact nature of the reduction depends on the specific consistency property. Technically, the notion of a correct sequential execution is system dependent, so it needs to be specified as well, but it is often obvious and therefore omitted. </p>
<p>We now give some examples of sequential equivalence.</p>
<p><font color=red>线性化</font>是一种强一致性。直白的说，线性一致性的约束是这样的：每个操作都是在起始时间到结束时间之间的某个时刻上即时执行的，这些时刻上执行的操作形成了有效的执行序列。更精确的说法是，我们在并发执行的操作上定义一个偏序，如下：如果<code>op1</code>结束后<code>op2</code>才开始执行，则<code>op1 &lt; op2</code>。线性一致性必须存在一个所有操作及其结果形成的合法的总序<code>T</code>，<code>T</code>满足(1)<code>T</code>满足<code>&lt;</code>的要求，即如果<code>op1 &lt; op2</code>，那T中<code>op1</code>必须在<code>op2</code>之前；(2)<code>T</code>定义了正确的顺序执行。线性一致性通常用于定义并发数据结构的正确行为，最近它常被用于分布式系统中。</p>
<p>Linearizability [12] is a strong form of consistency. Intuitively, the constraint is that each operation must appear to occur at an instantaneous point between its start and finish times, where execution at these instantaneous points form a valid sequential execution. More precisely, we define a partial order &lt; from the concurrent execution, as follows: op1 &lt; op2 if op1 finishes before op2 starts. There must exist a legal total order T of all operations with their results, such that (1) T is consistent with &lt;, meaning that if op1 &lt; op2 then op1 appears before op2 in T, and (2) T defines a correct sequential execution. Linearizability has been traditionally used to define the correct behavior of concurrent data structures; more recently, it has also been used in distributed systems.</p>
<p><font color=red>顺序一致性</font>也是一种强一致性，尽管比线性一致性稍弱。直白的说，它要求操作的执行就像完全按照每个Client发出操作的顺序进行排序一样。更精确的说法是，我们定义一个偏序，如下：如果<code>op1</code>和<code>op2</code>都是由同一个Client发起的，并且<code>op1</code>结束后<code>op2</code>才开始执行，则<code>op1 &lt; op2</code>。必须存在一个总序<code>T</code>：(1)<code>T</code>满足&lt;的要求，即如果<code>op1 &lt; op2</code>，那<code>T</code>中<code>op1</code>必须在<code>op2</code>之前；(2)<code>T</code>定义了正确的顺序执行。这些条件与线性一致性很类似，唯一的不同是偏序&lt;仅仅反映的是每个Client上本地触发的操作的顺序。顺序一致性用于定义计算机中的强一致性内存模型，但也可以在并发数据结构的上下文中使用。</p>
<p>Sequential consistency [14] is also a strong form of consistency, albeit weaker than linearizability. Intuitively, it requires that operations execute as if they were totally ordered in a way that respects the order in which each client issues operations. More precisely, we define a partial order &lt; as follows: op1 &lt; op2 if both operations are executed by the same client and op1 finishes before op2 starts. There must exist a total order T such that (1) T is consistent with &lt;, and (2) T defines a correct sequential execution. These conditions are similar to linearizability, except that &lt; reflects just the local order of operations at each client. Sequential consistency is used to define a strongly consistent memory model of a computer, but it could also be used in the context of concurrent data structures.</p>
<p>下一个示例涉及支持事务的系统。直白的说，事务要求一个或多个操作必须作为整体来执行。更准确的说法是，有专门的操作来启动、提交和中止事务；而且操作的数据条目与事务关联。系统提供了隔离属性，确保事务之间不会相互干扰。隔离属性有多种：串行化、强会话串行化、保序串行化、快照隔离、读已提交、可重复读等等。所有这些都属于操作一致性的范畴，其中一些属于顺序等价性。下面是一些示例，所有这些示例都是在数据库系统的上下文中使用。</p>
<p>The next examples pertain to systems that support transactions. Intuitively, a transaction is a bundle of one or more operations that must be executed as a whole. More precisely, there are special operations to start, commit, and abort transactions; and operations on data items are associated with a transaction. The system provides an isolation property, which ensures that transactions do not significantly interfere with one another. There are many isolation properties: serializability, strong session serializability, order-preserving serializability, snapshot isolation, read committed, repeatable reads, etc. All of these are forms of operation consistency, and several of them are of the sequential equivalence subcategory. Here are some examples, all of which are used in the context of database systems.</p>
<p><font color=red>串行化</font>就是直观的保证每个事务看起来都是串行执行的。更准确的说法是，串行化对系统中的操作施加的约束是：与这些操作相对应的调度必须等效于事务的串行调度。串行调度称为调度的串行化。</p>
<p>Serializability [5] intuitively guarantees that each transaction appears to execute in series. More precisely, serializability imposes a constraint on the operations in a system: the schedule corresponding to those operations must be equivalent to a serial schedule of transactions. The serial schedule is called a serialization of the schedule.</p>
<p><font color=red>强会话串行化</font>解决了串行化的问题。<font color=red>串行化允许同一Client的事务的重排序</font>，但有时不希望如此。强会话串行化在串行化之上施加了额外的约束。更准确地说，每个事务都与一个会话相关联，约束条件是在保持串行化的基础上（如上所述），还必须遵守每个会话中事务的顺序：如果同一个会话中，事务<code>T1</code>发生在<code>T2</code>之前，那么串行化顺序中<code>T2</code>不会在<code>T1</code>之前。</p>
<p>Strong session serializability [8] addresses an issue with serializability. Serializability allows transactions of the same client to be reordered, which can be undesirable at times. Strong session serializability imposes additional constraints on top of serializability. More precisely, each transaction is associated with a session, and the constraint is that serializability must hold (as defined above) and the serialization must respect the order of transactions within every session: if transaction T1 occurs before T2 in the same session, then T2 is not serialized before T1.</p>
<p><font color=red>保序串行化</font>，也称为严格串行化或强串行化，要求串行化顺序必须保持事务的实时顺序。更准确地说，约束条件是在保证串行化的基础上，还须满足以下要求：如果事务<code>T1</code>在<code>T2</code>开始之前提交，那么串行化顺序中<code>T2</code>不会出现在T1之前。</p>
<p>Order-preserving serializability [24], also called strict serializability [6, 17] or strong serializability [7], requires that the serialization order respect the real-time ordering of transactions. More precisely, the constraint is that serializability must hold and the serialization must satisfy the requirement that, if transaction T1 commits before T2 starts, then T2 is not serialized before T1.</p>
<h5 id="3-2-2-Reference-equivalence-引用等效性"><a href="#3-2-2-Reference-equivalence-引用等效性" class="headerlink" title="3.2.2 Reference equivalence     引用等效性"></a>3.2.2 Reference equivalence     引用等效性</h5><p><em>本节看不太懂，个人理解：引用就是顺序的一种泛化，是人为定义的一种关系，满足这种关系的操作就符合引用等效性</em></p>
<p>引用等价是顺序等价的泛化。它通过要求并发执行等效于给定引用来定义允许的操作结果，其中等效的概念和引用取决于具体的一致性属性。现在我们给出一些事务系统的示例。这些示例经常出现在数据库系统的上下文中。</p>
<p>Reference equivalence is a generalization of sequential equivalence. It defines the permitted operation results by requiring the concurrent execution to be equivalent to a given reference, where the notion of equivalence and the reference depend on the consistency property. We now give some examples for systems with transactions. These examples occur often in the context of database systems.</p>
<p>快照隔离要求事务的行为与某个引用实现相同，即事务必须具有与引用实现相同的结果，并且操作必须返回相同的结果。引用实现如下。当事务开始时，它会被分配一个单调的开始时间戳。当事务读取数据时，它从开始时间戳对应的快照中读取。当事务<code>T1</code>希望提交时，系统获得单调的提交时间戳，并验证是否存在其他事务<code>T2</code>，满足(1)<code>T2</code>更新<code>T1</code>也更新的某个项目，并且(2)<code>T2</code>使用<code>T1</code>的开始和提交时间戳之间的提交时间戳提交。如果是，则<code>T1</code>中止；否则，<code>T1</code>将被提交，并且以<code>T1</code>的提交时间戳，将其所有更新立即应用。</p>
<p>Snapshot isolation [4] requires that transactions behave identically to a certain reference implementation, that is, transactions must have the same outcome as in the reference implementation, and operations must return the same results. The reference implementation is as follows. When a transaction starts, it gets assigned a monotonic start timestamp. When the transaction reads data, it reads from a snapshot of the system as of the start timestamp. When a transaction T1 wishes to commit, the system obtains a monotonic commit timestamp and verifies whether there is some other transaction T2 such that (1) T2 updates some item that T1 also updates, and (2) T2 has committed with a commit timestamp between T1’s start and commit timestamp. If so, then T1 is aborted; otherwise, T1 is committed and all its updates are applied instantaneously as of the time of T1’s commit timestamp.</p>
<p>有趣的是，接下来的两个属性是引用等价的示例，而其中引用本身则由另一个一致性属性定义。在第一个示例中，引用等效属性属于串行等效子类型，在第二个示例中，它属于引用等效子类型。</p>
<p>Interestingly, the next two properties are examples of reference equivalence where the reference is itself defined by another consistency property. This other property is in the serial equivalence subcategory in the first example, and it is in the reference equivalence subcategory in the second example.</p>
<p>单副本的可序列化性属于复制的数据库系统。复制系统的行为必须类似于引用系统，该引用系统是一个未被复制并提供可序列化性的系统。</p>
<p>One-copy serializability [5] pertains to a replicated database system. The replicated system must behave like a reference system, which is a system that is not replicated and provides serializability.</p>
<p>单副本快照隔离也适用于复制系统。要求是，它的行为必须像一个未复制的系统，并提供快照隔离。</p>
<p>One-copy snapshot isolation [15] also pertains to a replicated system. The requirement is that it must behave like a system that is not replicated and that provides snapshot isolation.</p>
<h5 id="3-2-3-Read-write-centric-以读写为中心"><a href="#3-2-3-Read-write-centric-以读写为中心" class="headerlink" title="3.2.3 Read-write centric     以读写为中心"></a>3.2.3 Read-write centric     以读写为中心</h5><p>上述操作一致性的子类型适用于具有任意操作的系统。而以约束读写为核心的一致性子类型适用于具有两个非常特定操作–读和写–的系统。这些系统包括许多存储系统，如块存储系统、键值存储系统和访问内存的处理器。通过关注这两个操作，这种子类型的一致性允许直接使用操作的语义。特别是，写入操作只返回确认或错误状态，而不返回任何信息，所以写操作不会影响一致性。因此，<font color=red>这种一致性属性侧重于读的结果</font>。正如我们现在所解释的，这些属性的共同点是，读取可以看到一组写入的值。每次读取都会受到系统中写入的影响；如果每次写入都覆盖整个数据项，则写入操作将相互覆盖，读取操作将返回其中一个写入的值。但是，如果写入只更新了数据项的一部分，则读取将以适当的顺序返回写入值的组合。无论哪种情况，关键的考虑因素都是可能影响读取的写入集，而不管写入是否是部分写入；我们说，读能看到写。这个概念用于定义几个已知的一致性属性，我们现在举例说明。</p>
<p>The above subcategories of operation consistency apply to systems with arbitrary operations. The read-write centric subcategory applies to systems with two very specific operations: read and write. These systems are important because they include many types of storage systems, such as block storage systems, key value storage systems, and processors accessing memory. By focusing on the two operations, this subcategory permits properties that directly evoke the semantics of the operations. In particular, a write operation returns no information other than an acknowledgment or error status, which has no consistency implications. Thus, the consistency properties focus on the results of reads. Common to these properties is the notion of a read seeing the values of a set of writes, as we now explain. Each read is affected by some writes in the system; if every write covers the entire data item, then writes overwrite each other and the read returns the value written by one of them. But if the writes update just part of a data item, the read returns a combination of the written values in some appropriate order. In either case, the crucial consideration is the set of writes that could have potentially affected the read, irrespective of whether the writes are partial or not; we say that the read sees those writes. This notion is used to define several known consistency properties, as we now exemplify.</p>
<p><font color=red>“Read-my-writes”</font>要求，按照它们的执行顺序，Client的读操作至少能看到<font color=red>同一Client</font>以前执行的所有写操作。这种一致性适用于当Client希望能观察自己的写操作，但在观察他人的写操作时可以容忍延迟的情况。“Read-my-writes”通常与另一个读写一致性属性相结合，比如有界陈旧性或操作最终一致性。所谓结合，意思是系统必须同时满足“Read-my-writes”一致性和另一个一致性属性。“Read-my-writes”最初是在分布式系统的上下文中定义的，然后在计算机体系结构中用于定义内存模型。</p>
<p>Read-my-writes [21] requires that a read by a client sees at least all writes previously executed by the same client, in the order in which they were executed. This property is relevant when clients expect to observe their own writes, but can tolerate delays before observing the writes of others. Typically, read-my-writes is combined with another read-write consistency property, such as bounded staleness or operational eventual consistency, defined below. By combined we mean that the system must provide both read-my-writes and the other property. Read-my-writes was originally defined in the context of distributed systems [21], then used in computer architecture to define memory models [19].</p>
<p><font color=red>有界陈旧性</font>直观地限制了读操作看到写操作所需的时间。更准确地说，该属性有一个参数<code>e</code>，因此读取必须至少在读取开始之前的<code>e</code>时间内看到所有已完成的写入。该属性适用于可以容忍不一致的时间范围为<code>e</code>的场景，或者是小于e的时间范围client无法感知的场景。有界陈旧性最初用在数据库系统的上下文中，后来也在云分布式系统的上下文中使用。</p>
<p>Bounded staleness [1], intuitively, bounds the time it takes for writes to be seen by reads. More precisely, the property has a parameter e, such that a read must see at least all writes that complete e time before the read started. This property is relevant when inconsistencies are tolerable in the short term as defined by e, or when time intervals smaller than e are imperceptible by clients (e.g., e is in the tens of milliseconds and clients are humans). Bounded staleness was originally defined in the context of database systems [1] and has been used more recently in the context of cloud distributed systems [20].</p>
<p>操作<font color=red>最终一致性</font>是最终一致性（状态一致性的一种形式）的变体。要求是每次写入最终都能被所有读取看到，如果Client停止执行写入，那么每次读取最终都会返回相同的最新值。</p>
<p>Operational eventual consistency is a variant of eventual consistency (a form of state consistency) defined using operation consistency. The requirement is that each write be eventually seen by all reads, and if clients stop executing writes then eventually every read returns the same latest value [22].</p>
<p>缓存一致性源于计算机体系结构，用于定义内存缓存的正确行为。直观地说，缓存一致性要求对单个数据项（内存位置）的读写满足某些属性。文献中的属性各不相同。一种是要求对于每个数据项：(1)某个Client的读取能返回该Client之前写入的值，除非另一个Client在这期间进行了写入；(2)如果写入和读取在时间上充分分离，并且在这两个操作之间没有发生其他写入，则读取能返回另一个Client的写入值；（3）写操作是序列化的。</p>
<p>Cache coherence originates from computer architecture to define the correct behavior of a memory cache. Intuitively, cache coherence requires that reads and writes to an individual data item (a memory location) satisfy some properties. The properties vary across the literature. One possibility [11] is to require that, for each data item: (1) a read by some client returns the value of the previous write by that client, unless another client has written in between, (2) a read returns the value of a write by another client if the write and read are sufficiently separated in time and if no other write occurred in between, and (3) writes are serialized.</p>
<h4 id="3-3-Discussion-讨论"><a href="#3-3-Discussion-讨论" class="headerlink" title="3.3 Discussion     讨论"></a>3.3 Discussion     讨论</h4><p>现在，我们根据抽象级别、复杂性、能力和应用程序依赖性来比较状态一致性和操作一致性。</p>
<p>We now compare state consistency and operation consistency in terms of their level of abstraction, complexity, power, and application dependence.</p>
<h5 id="3-3-1-Level-of-abstraction-抽象级别"><a href="#3-3-1-Level-of-abstraction-抽象级别" class="headerlink" title="3.3.1 Level of abstraction     抽象级别"></a>3.3.1 Level of abstraction     抽象级别</h5><p>操作一致性是一个端到端的属性，因为它处理的是Client可以直接观察到的结果。这与状态一致性相反，状态一致性处理Client通过执行操作间接观察到的系统状态。换句话说，操作一致性比状态一致性处于更高的抽象级别。因此，<font color=red>系统可能存在严重的状态不一致性，但可以从外部隐藏这些不一致性，以提供强大的操作一致性。</font></p>
<p>Operation consistency is an end-to-end property, because it deals with results that clients can observe directly. This is in contrast to state consistency, which deals with system state that clients observe indirectly by executing operations. In other words, operation consistency is at a higher level of abstraction than state consistency. As a result, a system might have significant state inconsistencies, but hide these inconsistencies externally to provide a strong form of operation consistency.</p>
<p>一个有趣的例子是一个有3个节点的存储系统，3个节点使用majority quorum进行复制，其中(1)为了写入数据，系统附加了一个单调的时间戳，并将数据存储在2个（大多数）节点上；(2)为了读取，系统从两个节点上获取数据；如果节点返回相同的数据，系统将数据返回给Client；否则，系统会选取时间戳最高的数据，将该数据及其时间戳存储在另一台节点中（以确保两个节点都有数据），然后将数据返回给客户端。此系统违反了相互一致性，因为当没有未完成的操作时，其中一个节点会与其他两个节点不一致。然而，这种不一致性在read返回的结果中是看不到的，因为read通过查询多数来过滤不一致的节点。事实上，此存储系统满足线性一致性，这是操作一致性的最强形式之一。</p>
<p>An interesting example is a storage system with three servers replicated using majority quorums [3], where (1) to write data, the system attaches a monotonic timestamp and stores the data at two (a majority of) servers, and (2) to read, the system fetches the data from two servers; if the servers return the same data, the system returns the data to the client; otherwise, the system picks the data with the highest timestamp, stores that data and its timestamp in another server (to ensure that two servers have the data), and returns the data to the client. This system violates mutual consistency, because when there are no outstanding operations, one of the servers deviates from the other two. However, this inconsistency is not observable in the results returned by reads, since a read filters out the inconsistent server by querying a majority. In fact, this storage system satisfies linearizability, one of the strongest forms of operation consistency.</p>
<h5 id="3-3-2-Complexity-复杂性"><a href="#3-3-2-Complexity-复杂性" class="headerlink" title="3.3.2 Complexity     复杂性"></a>3.3.2 Complexity     复杂性</h5><p>操作一致性比状态一致性更复杂。通过状态一致性，开发人员可以直接了解他们可以从系统中期望的状态。每个属性都关注于不依赖执行的特定数据项。因此，状态一致性是直观的，易于表达和理解。此外，可以通过分析系统状态的快照来检查状态一致性，这有助于调试。</p>
<p>Operation consistency is more complex than state consistency. With state consistency, developers gain a direct understanding of what states they can expect from the system. Each property concerns specific data items that do not depend on the execution. As a result, state consistency is intuitive and simple to express and under-stand. Moreover, state consistency can be checked by analyzing a snapshot of the system state, which facilitates debugging.</p>
<p>相比之下，操作一致性属性在操作之间建立了关系，这些操作随着时间的推移可能会分布在多个Client上，这会造成复杂性。从第3.2节中的示例可以看出，这种复杂性使得操作一致性不那么直观，更难理解。此外，检查操作一致性需要分析执行日志，这会使调试复杂化。</p>
<p>By contrast, operation consistency properties establish relations between operations that are spread over time and possibly over many clients, which creates complexity. This complexity makes operation consistency less intuitive and harder to understand, as can be observed from the examples in Section 3.2. Moreover, checking operation consistency requires analyzing an execution log, which complicates debugging.</p>
<h5 id="3-3-3-Power-能力"><a href="#3-3-3-Power-能力" class="headerlink" title="3.3.3 Power     能力"></a>3.3.3 Power     能力</h5><p>操作一致性和状态一致性具有不同的能力。操作一致性可以看到系统中的所有操作，从而约束操作的顺序和结果。如果系统是确定性的，那么操作一致性属性可以从操作中重构系统的状态，从而间接地约束状态，就像状态一致性一样。但是，当系统不确定时（例如，由于并发、计时或外部事件），通常不可能这样做。</p>
<p>Operation consistency and state consistency have different powers. Operation consistency can see all operations in the system, which permits constraining the ordering and results of operations. If the system is deterministic, operation consistency properties can reconstruct the state of the system from the operations, and thereby indirectly constrain the state much like state consistency. But doing so is not generally possible when the system is non-deterministic (e.g., due to concurrency, timing, or external events).</p>
<p>另一方面，状态一致性可以看到系统的整个状态，从而可以约束可能破坏状态的操作。如果系统在其状态下记录其所有操作，则状态一致性可以像操作一致性一样间接约束操作的结果。然而，通常禁止记录所有操作，因此这只是一种理论能力。</p>
<p>State consistency, on the other hand, can see the entire state of the system, which permits constraining operations that might break the state. If the system records all its operations in its state, then state consistency can indirectly constrain the results of operations much like operation consistency. However, it is often prohibitive to record all operations so this is only a theoretical capability.</p>
<h5 id="3-3-4-Application-dependence-应用程序依赖性"><a href="#3-3-4-Application-dependence-应用程序依赖性" class="headerlink" title="3.3.4 Application dependence     应用程序依赖性"></a>3.3.4 Application dependence     应用程序依赖性</h5><p>状态一致性往往依赖于应用程序，因为属性涉及状态，并且系统的正确状态因应用程序而异。因此，开发人员需要为每个系统找出正确的属性，这需要时间和精力。此外，在某些情况下，没有强制执行状态一致性的通用机制，开发人员必须编写与每个属性密切相关的应用程序代码。有两个值得注意的例外：相互一致性和最终一致性。这些属性通过引用复制状态而广泛应用于任何复制的系统，而与应用程序无关，并且有通用的复制机制来强制执行这些属性。</p>
<p>State consistency tends to be application dependent, because the properties concern state, and the correct state of a system varies significantly from application to application. As a result, developers need to figure out the right properties for each system, which takes time and effort. Moreover, in some cases there are no general mechanisms to enforce state consistency and developers must write application code that is closely tied to each property. There are two noteworthy exceptions: mutual consistency and eventual consistency. These properties apply broadly to any replicated system, by referring to the replicated state irrespective of the application, and there are general replication mechanisms to enforce such properties.</p>
<p>操作一致性通常与应用程序无关。它通过两种方式实现应用程序独立性。首先，一些属性通过将并发操作下的系统行为减少为顺序操作下的行为（如在顺序等价子类型中）或引用下的行为（如在引用等价子类型中）来考虑特定于应用程序的行为。其次，一些属性侧重于应用于许多系统的特定操作，如读和写（如以读写为中心的子类型）。理论上，操作一致性可能高度依赖于应用程序，但这并不常见。例如，许多设备都可以访问电子邮件系统，其中每个操作（读取、删除、移动）可能根据其语义和用户的期望对其响应有不同的约束。</p>
<p>Operation consistency is often application independent. It achieves application independence in two ways. First, some properties factor out the application-specific behavior, by reducing the behavior of the system under concurrent operations to behavior under sequential operations (as in the sequential equivalence subcategory), or behavior under a reference (as in the reference equivalence subcategory). Second, some properties focus on specific operations, such as read and write, that apply to many systems (as in the read-write centric subcategory). Theoretically, operation consistency can be highly application dependent, but this is not common. An example might be an email system accessible by many devices, where each operation (read, delete, move) might have different constraints on their response according to their semantics and the expectations of users.</p>
<h5 id="3-3-5-Which-type-to-use-使用哪一种"><a href="#3-3-5-Which-type-to-use-使用哪一种" class="headerlink" title="3.3.5 Which type to use?     使用哪一种"></a>3.3.5 Which type to use?     使用哪一种</h5><p>要决定使用哪种类型的一致性，我们建议考虑以下几点。首先，<font color=red>思考一致性的反面：必须避免的不一致是什么？</font>如果答案用不需要的状态来描述更容易的话（例如，两个副本不一致），则使用状态一致性。如果答案由操作的错误结果描述更容易的话（例如，读取返回陈旧数据），则使用操作一致性。</p>
<p>To decide what type of consistency to use, we suggest taking a few things into consideration. First, think about the negation of consistency: what are the inconsistencies that must be avoided? If the answer is most easily described by an undesirable state (e.g., two replicas diverge), then use state consistency. If the answer is most easily described by an incorrect result to an operation (e.g., a read returns stale data), then use operation consistency.</p>
<p>第二个重要的考虑因素是应用程序依赖性。许多操作一致性和一些状态一致性属性与应用程序无关（例如，可串行化、线性化、相互一致性、最终一致性）。我们建议在定义特定于应用程序的属性之前尝试使用这些属性，因为它们的机制已经很好地理解了。如果系统需要特定于应用程序的属性，并且状态和操作一致性都是自然选择，那么由于其简单性，我们建议使用状态一致性。</p>
<p>A second important consideration is application dependency. Many operation consistency and some state consistency properties are application independent (e.g., serializability, linearizability, mutual consistency, eventual consistency). We recommend trying to use such properties, before defining an application-specific one, because the mechanisms to enforce them are well understood. If the system requires an application specific property, and state and operation consistency are both natural choices, then we recommend using state consistency due to its simplicity.</p>
<h3 id="4-Consistency-in-different-disciplines-不同学科的一致性"><a href="#4-Consistency-in-different-disciplines-不同学科的一致性" class="headerlink" title="4 Consistency in different disciplines     不同学科的一致性"></a>4 Consistency in different disciplines     不同学科的一致性</h3><p>现在，我们将在第3节中讨论一致性在每个学科中的含义，为什么它与该学科相关，以及它如何与这两种类型的一致性相关。我们还指出了在一个学科中被认为是一致的概念，但在另一个学科中则不一致。</p>
<p>We now discuss what consistency means in each discipline, why it is relevant in that discipline, and how it relates to the two types of consistency in Section 3. We also point out concepts that are considered to be consistency in one discipline but not in another.</p>
<h4 id="4-1-Distributed-systems-分布式系统"><a href="#4-1-Distributed-systems-分布式系统" class="headerlink" title="4.1 Distributed systems     分布式系统"></a>4.1 Distributed systems     分布式系统</h4><p>在分布式系统中，一致性指的是状态一致性或操作一致性。早期的复制协议侧重于提供相互一致性，而许多云分布式系统则提供最终的一致性。这些是状态一致性的示例。一些系统旨在提供线性化能力或各种以读写为中心的一致性。这些是操作一致性的示例。</p>
<p>In distributed systems, consistency refers to either state or operation consistency. Early replication protocols focused on providing mutual consistency while many cloud distributed systems provide eventual consistency. These are examples of state consistency. Some systems aim at providing linearizability or various flavors of read-write centric consistency. These are examples of operation consistency.</p>
<p>在分布式系统中，一致性是一个重要的考虑因素，因为这类系统面临着许多妨碍或阻碍一致性的问题：由慢速网络分隔的Client、发生故障的机器、相互断开连接的Client、系统对大量Client的可扩展性以及高可用性。这些问题可能会导致难以提供高水平的一致性，因为一致性需要客户协调，而这可能是不可能的。因此，分布式系统可能会采用较弱的一致性级别，根据应用程序的需要进行选择。</p>
<p>Consistency is an important consideration in distributed systems because such systems face many concerns that preclude or hinder consistency: clients separated by a slow network, machines that fail, clients that disconnect from each other, scalability of the system to a large number of clients, and high availability. These concerns can make it hard to provide strong levels of consistency, because consistency requires client coordination that may not be possible. As a result, distributed systems may adopt weaker levels of consistency, chosen according to the needs of applications.</p>
<p>云系统是一种有趣的分布式系统，它面临着上述所有问题：系统是地理分布的（分布在全球各地），数据中心之间存在显著的延迟分离；机器经常失败，因为它们太多了；由于广域链路出现问题或拥塞，Client与远程数据中心断开连接；许多客户都很活跃，系统必须为所有客户提供良好的服务；而且该系统必须尽可能可用，因为企业在停机期间会亏损。由于这些挑战，云系统通常求助于较弱的一致性级别。</p>
<p>Cloud systems, an interesting type of distributed system, face all of the above concerns with intensity: the systems are geo-distributed (distributed around the globe) with significant latency separating data centers; ma-chines fail often because there are many of them; clients disconnect from remote data centers due to problems or congestion in wide-area links; many clients are active and the system must serve all of them well; and the system must be available whenever possible since businesses lose money during downtime. Because of these challenges, cloud systems often resort to weak levels of consistency.</p>
<h4 id="4-2-Database-systems-数据库系统"><a href="#4-2-Database-systems-数据库系统" class="headerlink" title="4.2 Database systems     数据库系统"></a>4.2 Database systems     数据库系统</h4><p>在数据库系统中，<font color=red>一致性是指状态一致性</font>。例如，考虑描述交易担保的ACID首字母缩略词。“C”代表一致性，在这种情况下，这意味着<font color=red>数据库始终处于开发人员认为有效的状态：系统必须保持不变式，</font>例如唯一性约束、引用完整性和特定于应用程序的属性（例如，如果y是x的朋友，则x是y的朋友）。这些都是状态一致性。</p>
<p>In database systems, consistency refers to state consistency. For example, consider the ACID acronym that de-scribes the guarantees of transactions. The “C” stands for consistency, which in this case means that the database is always in a state that developers consider valid: the system must preserve invariants such as uniqueness con-straints, referential integrity, and application-specific properties (e.g., x is a friend of y iff y is a friend of x). These are flavors of state consistency.</p>
<p>“A”代表原子性，“I”代表隔离。有趣的是，原子性和隔离是操作一致性的例子。原子性要求事务要么整体执行，要么根本不执行，而隔离要求事务看起来是自己执行，没有太多干扰。有许多不同级别的隔离（可串行化、快照隔离、已提交读取、可重复读取等），但它们都限制了操作的行为。</p>
<p>The “A” stands for atomicity and the “I” stands for isolation. Interestingly, atomicity and isolation are examples of operation consistency. Atomicity requires that a transaction either executes in its entirety or does not execute at all, while isolation requires that transactions appear to execute by themselves without much interference. There are many different levels of isolation (serializability, snapshot isolation, read committed, repeatable reads, etc), but they all constrain the behavior of operations.</p>
<p>虽然数据库系统社区将事务隔离与一致性和原子性分开，但在分布式系统社区中，事务隔离被视为一致性的一种形式，而在计算机体系结构社区中，类似于隔离的概念被称为原子性。我们不知道为什么这些术语在社区中有不同的含义。但我们怀疑其中的一个原因是，这些概念之间存在相互交织的想法，这是我们在本文中试图确定和澄清的。</p>
<p>Although the database systems community separates transaction isolation from consistency and atomicity, in the distributed systems community, transaction isolation is seen as a form of consistency, while in the computer architecture community, a concept analogous to isolation is called atomicity. We do not know exactly why these terms have acquired different meanings across communities. But we suspect that a reason is that there are intertwined ideas across these concepts, which is something we try to identify and clarify in this article.</p>
<p>一致性在数据库系统中很重要，因为数据是首要考虑的问题；事实上，数据可能比此类系统中操作的结果更重要（例如，只要数据不被破坏，操作就可能失败）。不同类型的一致性是由于数据库中存在不同类型的不变量，每个不变量都有自己的强制机制。例如，唯一性约束由执行引擎中的索引和检查强制执行；应用程序特定的约束由应用程序逻辑强制执行；而相互一致性是由replication manager实施的。</p>
<p>Consistency is important in database systems because data is of primary concern; in fact, data could be even more important than the result of operations in such systems (e.g., operations can fail as long as data is not destroyed). Different types of consistency arise because of the different classes of invariants that exist in the database, each with its own enforcement mechanism. For example, uniqueness constraints are enforced by an index and checks in the execution engine; application-specific constraints are enforced by the application logic; and mutual consistency is enforced by the replication manager.</p>
<h4 id="4-3-Computer-architecture-计算机体系结构"><a href="#4-3-Computer-architecture-计算机体系结构" class="headerlink" title="4.3 Computer architecture     计算机体系结构"></a>4.3 Computer architecture     计算机体系结构</h4><p>在计算机体系结构中，一致性是指操作的一致性。一个类似的称为coherence的概念也是操作一致性的一种形式。Consistency和Coherence 有细微的区别。Consistency涉及整个内存系统；它限制整个内存系统的读取和写入的行为；Coherence 涉及缓存子系统，这可以看作是负责给定内存位置的各种缓存操作的一致性。因此，Coherence 限制了加载和存储到单个内存位置的行为。</p>
<p>In computer architecture, consistency refers to operation consistency. A similar concept called coherence is also a form of operation consistency. Consistency and coherence have a subtle difference. Consistency concerns the entire memory system; it constrains the behavior of reads and writes—called loads and stores—across all the memory locations; an example is the sequential consistency property. Coherence concerns the cache subsystem; it can be seen as consistency of the operation of the various caches responsible for a given memory location. Thus, coherence constrains the behavior of loads and stores to an individual memory location.</p>
<p>Coherence 和consistency 是分开的，以允许系统的模块化体系结构：缓存一致性协议确保缓存子系统的正确行为，而系统的其余部分确保跨内存访问的一致性，而无需担心缓存子系统。</p>
<p>Coherence and consistency are separated to permit a modular architecture of the system: a cache coherence protocol ensures the correct behavior of the caching subsystem, while the rest of the system ensures consistency across memory accesses without worrying about the cache subsystem.</p>
<p>Consistency 和coherence 是计算机体系结构中的一个问题，因为越来越多的计算机系统有许多内核或处理器共享对公共内存的访问：在这样的系统中，内存位置上的并发操作和跨多个缓存的数据复制会导致数据共享问题。</p>
<p>Consistency and coherence arise as issues in computer architecture because increasingly computer systems have many cores or processors sharing access to a common memory: in such systems, there are concurrent operations on memory locations and data replication across many caches, which lead to problems of data sharing.</p>
<h3 id="5-Conclusion-总结"><a href="#5-Conclusion-总结" class="headerlink" title="5 Conclusion     总结"></a>5 Conclusion     总结</h3><p>正如我们在这里简要描述的那样，一致性是一个跨多学科的重要问题。这种重要性源于这些学科中的并发和复制的兴起，我们预期这一趋势会继续下去。不幸的是，一致性很微妙，很难把握，更糟糕的是，它在不同的领域有不同的名称和含义。我们希望通过确定两种广泛且非常不同的一致性类型，即跨学科的状态一致性和操作一致性，来阐明这一主题。</p>
<p>Consistency is a concern that spans many disciplines, as we briefly described here. This concern stems from the rise of concurrency and replication across these disciplines, a trend that we expect to continue. Unfortunately, consistency is subtle and hard to grasp, and to make matters worse, it has different names and meanings across communities. We hope to have shed some light on this subject by identifying two broad and very different types of consistency—state consistency and operation consistency—that can be seen across the disciplines.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag"># 分布式</a>
              <a href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/" rel="tag"># 一致性</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/27/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7/jepsen/12Repeatable%20Read/" rel="prev" title="12Repeatable Read">
      <i class="fa fa-chevron-left"></i> 12Repeatable Read
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/05/29/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7/jepsen/13Snapshot%20Isolation/" rel="next" title="13Snapshot Isolation">
      13Snapshot Isolation <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Introduction-%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">1 Introduction     引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Abstract-model-%E6%8A%BD%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">2 Abstract model     抽象模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Two-types-of-consistency-%E4%B8%A4%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">3.</span> <span class="nav-text">3 Two types of consistency     两种类型的一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-State-consistency-%E7%8A%B6%E6%80%81%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 State consistency     状态一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-1-Invariants-%E4%B8%8D%E5%8F%98%E5%BC%8F"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1 Invariants     不变式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-2-Error-bounds-%E6%9C%89%E7%95%8C%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2 Error bounds     有界不一致</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-3-Limits-on-proportion-of-violations-%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E6%AF%94%E4%BE%8B%E9%99%90%E5%88%B6"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.1.3 Limits on proportion of violations     不一致的比例限制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-4-Importance-%E4%B8%80%E8%87%B4%E6%80%A7%E7%AD%89%E7%BA%A7"><span class="nav-number">3.1.4.</span> <span class="nav-text">3.1.4 Importance     一致性等级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-5-Eventual-invariants-%E6%9C%80%E7%BB%88%E4%B8%8D%E5%8F%98%E5%BC%8F"><span class="nav-number">3.1.5.</span> <span class="nav-text">3.1.5 Eventual invariants     最终不变式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-Operation-consistency-%E6%93%8D%E4%BD%9C%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 Operation consistency     操作一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-1-Sequential-equivalence-%E9%A1%BA%E5%BA%8F%E7%AD%89%E4%BB%B7%E6%80%A7"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 Sequential equivalence     顺序等价性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-Reference-equivalence-%E5%BC%95%E7%94%A8%E7%AD%89%E6%95%88%E6%80%A7"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2 Reference equivalence     引用等效性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-3-Read-write-centric-%E4%BB%A5%E8%AF%BB%E5%86%99%E4%B8%BA%E4%B8%AD%E5%BF%83"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.2.3 Read-write centric     以读写为中心</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-Discussion-%E8%AE%A8%E8%AE%BA"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 Discussion     讨论</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-1-Level-of-abstraction-%E6%8A%BD%E8%B1%A1%E7%BA%A7%E5%88%AB"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1 Level of abstraction     抽象级别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-Complexity-%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2 Complexity     复杂性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-Power-%E8%83%BD%E5%8A%9B"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3.3 Power     能力</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-4-Application-dependence-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BE%9D%E8%B5%96%E6%80%A7"><span class="nav-number">3.3.4.</span> <span class="nav-text">3.3.4 Application dependence     应用程序依赖性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-5-Which-type-to-use-%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%80%E7%A7%8D"><span class="nav-number">3.3.5.</span> <span class="nav-text">3.3.5 Which type to use?     使用哪一种</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Consistency-in-different-disciplines-%E4%B8%8D%E5%90%8C%E5%AD%A6%E7%A7%91%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text">4 Consistency in different disciplines     不同学科的一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-Distributed-systems-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 Distributed systems     分布式系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-Database-systems-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 Database systems     数据库系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-Computer-architecture-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 Computer architecture     计算机体系结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Conclusion-%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">5 Conclusion     总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="gqtc"
      src="/images/panda.gif">
  <p class="site-author-name" itemprop="name">gqtc</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">gqtc</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'DOtutT1RryAIysn71vbzynQy-gzGzoHsz',
      appKey     : 'KxMi4qDudMqAUjo5HbMTp5Ht',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
