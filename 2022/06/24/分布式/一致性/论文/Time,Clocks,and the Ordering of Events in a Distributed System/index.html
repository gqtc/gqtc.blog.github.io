<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/function%20()%20%7B%0A%20%20%20%20%20%20for%20(var%20_len2%20=%20arguments.length,%20args%20=%20new%20Array(_len2),%20_key2%20=%200;%20_key2%20%3C%20_len2;%20_key2++)%20%7B%0A%20%20%20%20%20%20%20%20args%5B_key2%5D%20=%20arguments%5B_key2%5D;%0A%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20return%20obj%5Bval%5D.apply(obj,%20args);%0A%20%20%20%20%7D">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","width":160,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Introduction时间概念是我们思维方式的基础。而它源于事件发生的顺序这个更基本的概念。事件的时间顺序的概念渗透到我们对系统的思考中。然而，在考虑分布式系统中的事件时，必须仔细重新审视这个概念。 The concept of time is fundamental to our way of thinking. It is derived from the more basic concep">
<meta property="og:type" content="article">
<meta property="og:title" content="Time,Clocks,and the Ordering of Events in a Distributed System">
<meta property="og:url" content="http://example.com/2022/06/24/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7/%E8%AE%BA%E6%96%87/Time,Clocks,and%20the%20Ordering%20of%20Events%20in%20a%20Distributed%20System/index.html">
<meta property="og:site_name" content="gqtc&#39;s blog">
<meta property="og:description" content="Introduction时间概念是我们思维方式的基础。而它源于事件发生的顺序这个更基本的概念。事件的时间顺序的概念渗透到我们对系统的思考中。然而，在考虑分布式系统中的事件时，必须仔细重新审视这个概念。 The concept of time is fundamental to our way of thinking. It is derived from the more basic concep">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=C_j(t%27-0)=lim_%7B%5Cdelta%5Crightarrow+0%7DC_j(t%27-%7C%5Cdelta%7C)">
<meta property="article:published_time" content="2022-06-23T16:00:00.000Z">
<meta property="article:modified_time" content="2022-06-29T05:44:37.895Z">
<meta property="article:author" content="gqtc">
<meta property="article:tag" content="分布式">
<meta property="article:tag" content="一致性">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.zhihu.com/equation?tex=C_j(t%27-0)=lim_%7B%5Cdelta%5Crightarrow+0%7DC_j(t%27-%7C%5Cdelta%7C)">

<link rel="canonical" href="http://example.com/2022/06/24/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7/%E8%AE%BA%E6%96%87/Time,Clocks,and%20the%20Ordering%20of%20Events%20in%20a%20Distributed%20System/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Time,Clocks,and the Ordering of Events in a Distributed System | gqtc's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">gqtc's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/24/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7/%E8%AE%BA%E6%96%87/Time,Clocks,and%20the%20Ordering%20of%20Events%20in%20a%20Distributed%20System/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/panda.gif">
      <meta itemprop="name" content="gqtc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gqtc's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Time,Clocks,and the Ordering of Events in a Distributed System
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-24 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-24T00:00:00+08:00">2022-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-29 13:44:37" itemprop="dateModified" datetime="2022-06-29T13:44:37+08:00">2022-06-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7/" itemprop="url" rel="index"><span itemprop="name">一致性</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7/%E8%AE%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">论文</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/06/24/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7/%E8%AE%BA%E6%96%87/Time,Clocks,and%20the%20Ordering%20of%20Events%20in%20a%20Distributed%20System/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/06/24/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7/%E8%AE%BA%E6%96%87/Time,Clocks,and%20the%20Ordering%20of%20Events%20in%20a%20Distributed%20System/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>时间概念是我们思维方式的基础。而它源于事件发生的顺序这个更基本的概念。事件的时间顺序的概念渗透到我们对系统的思考中。然而，在考虑分布式系统中的事件时，必须仔细重新审视这个概念。</p>
<p>The concept of time is fundamental to our way of thinking. It is derived from the more basic concept of the order in which events occur. We say that something happened at 3:15 if it occurred after our clock read 3:15 and before it read 3:16. The concept of the temporal ordering of events pervades our thinking about systems. For example, in an airline reservation system we specify that a request for a reservation should be granted if it is made before the flight is filled. However, we will see that this concept must be carefully reexamined when considering events in a distributed system.</p>
<span id="more"></span>
<p>分布式系统由一组在空间上分离的进程组成，这些进程通过交换消息相互通信。</p>
<p>A distributed system consists of a collection of distinct processes which are spatially separated, and which communicate with one another by exchanging messages. A network of interconnected computers, such as the ARPA net, is a distributed system. A single computer can also be viewed as a distributed system in which the central control unit, the memory units, and the input-output channels are separate processes. A system is distributed if the message transmission delay is not negligible compared to the time between events in a single process.</p>
<p>We will concern ourselves primarily with systems of spatially separated computers. However, many of our remarks will apply more generally. In particular, a multiprocessing system on a single computer involves problems similar to those of a distributed system because of the unpredictable order in which certain events can occur.</p>
<p><font color=red>在分布式系统中，有时说不清两个事件中的哪一个先发生。因此，“happened before”的关系只是系统中偏序关系。</font>我们发现这里经常会出问题，因为人们没有充分意识到这一事实及其影响。</p>
<p>In a distributed system, it is sometimes impossible to say that one of two events occurred first. The relation “happened before” is therefore only a partial ordering of the events in the system. We have found that problems often arise because people are not fully aware of this fact and its implications.</p>
<p>这篇论文中，我们讨论了由”happened before”关系定义的偏序关系，并给出了将其扩展到所有事件上的一致的全序关系上的分布式算法。该算法为实现一个分布式系统提供了一种有用的机制。我们用一个简单的用于解决同步问题的方法来距离说明该算法。如果通过该算法获得的顺序与用户感知的顺序不同，则可能会发生意外的异常行为。这可以通过引入真实的物理时钟来避免。我们描述了一种同步这些时钟的简单方法，并推导了它们偏离同步的上限。</p>
<p>In this paper, we discuss the partial ordering defined by the “happened before” relation, and give a distributed algorithm for extending it to a consistent total ordering of all the events. This algorithm can provide a useful mechanism for  implementing a distributed system. We illustrate its use with a simple method for solving synchronization problems. Unexpected, anomalous behavior can occur if the ordering obtained by this algorithm differs from that perceived by the user. This can be avoided by introducing real, physical clocks. We describe a simple method for synchronizing these clocks, and derive an upper bound on how far out of synchrony they can drift.</p>
<hr>
<h3 id="The-Partial-Ordering"><a href="#The-Partial-Ordering" class="headerlink" title="The Partial Ordering"></a>The Partial Ordering</h3><p>如果事件<code>a</code>发生的时间早于<code>b</code>，大多数人可能会说<code>a</code>发生在<code>b</code>之前（happened before）。他们可能会用时间的物理理论来证明这个定义。然而，如果<font color=red>想要系统满足某种规范，那必须根据系统内可观察到的事件来给出该规范。</font>如果该规范与物理时间相关，那系统必须包含实际的物理时钟。即使该系统确实包含真实的物理时钟，仍然存在这样的问题，因为这种时钟不可能是完全精确的，不能保持精确的物理时间。因此，我们将在不使用物理时钟的情况下定义“happened before”关系。</p>
<p>Most people would probably say that an event a happened before an event b if a happened at an earlier time than b. They might justify this definition in terms of physical theories of time. However, if a system is to meet a specification correctly, then that specification must be given in terms of events observable within the system. If the specification is in terms of physical time, then the system must contain real clocks. Even if it does contain real clocks, there is still the problem that such clocks are not perfectly accurate and do not keep precise physical time. We will therefore define the “happened before” relation without using physical clocks.</p>
<p>现在我们更加精确的定义系统。我们假设系统由一些进程组成。每个进程则包含一系列的事件，如果事件<code>a</code>在事件<code>b</code>之前发生，则这个序列中事件<code>a</code>会出现在事件<code>b</code>之前。因此单个进程可以定义为满足偏序关系的一组事件。</p>
<p>We begin by defining our system more precisely. We assume that the system is composed of a collection of processes. Each process consists of a sequence of events. Depending upon the application, the execution of a subprogram on a computer could be one event, or the execution of a single machine instruction could be one a sequence, where a occurs before b in this sequence if a happens before b. In other words, a single process is defined to be a set of events with an a priori total ordering. This seems to be what is generally meant by a process. It would be trivial to extend our definition to allow a process to split into distinct subprocesses, but we will not bother to do so. </p>
<p>我们假设进程中发送或者接收消息就是一个事件。因此我们将”happened before”关系表示为”–&gt;”，<font color=red>定义如下</font>：”–&gt;”是满足以下三个条件的最小关系：</p>
<ol>
<li>如果事件<code>a</code>和<code>b</code>是同一个进程中的事件，并且<code>a</code>出现在<code>b</code>之前，则<code>a--&gt;b</code>;</li>
<li>如果<code>a</code>是某个进程中发送消息的事件，而<code>b</code>是其他进程中接收该消息的事件，则<code>a--&gt;b</code>;</li>
<li>如果<code>a--&gt;b</code>并且<code>b--&gt;c</code>，则<code>a--&gt;c</code>。如果<code>a-/-&gt;b</code>，并且<code>b-/-&gt;a</code>，则两个事件<code>a</code>和<code>b</code>被认为是并发执行的；</li>
</ol>
<p>We assume that sending or receiving a message is an event in a process. We can then define the “happened before” relation, denoted by “–&gt;”, as follows. </p>
<p>Definition. The relation “–&gt;” on the set of events of a system is the smallest relation satisfying the following three conditions: (1) If a and b are events in the same process, and a comes before b, then a –&gt; b. (2) If a is the sending of a message by one process and b is the receipt of the same message by another process, then a –&gt; b. (3) If a –&gt; b and b –&gt; c then a –&gt; c. Two distinct events a and b are said to be concurrent if a -&#x2F;-&gt; b and b -&#x2F;-&gt; a. </p>
<p>我们假设任何事件<code>a</code>都满足<code>a-/-&gt;a</code>（在系统中的事件可以先于自身发生似乎没有物理意义）。这意味着<code>--&gt;</code>是系统中所有事件集上的<font color=red>偏序关系</font>。</p>
<p>We assume that a -&#x2F;-&gt; a for any event a. (Systems in which an event can happen before itself do not seem to be physically meaningful.) This implies that –&gt; is an irreflexive partial ordering on the set of all events in the system.</p>
<p>下面的时空图图1是个例子。横向表示空间，竖向表示时间，向上表示时间的递增。点表示事件，垂线表示进程，波浪线表示消息。容易看出，<code>a--&gt;b</code>意味着可以在消息线上从<code>a</code>转到<code>b</code>。比如图1中有<code>p1--&gt;p4</code>。</p>
<p>![image-20220614082038586](&#x2F;img&#x2F;Time,Clocks,and the Ordering of Events in a Distributed System&#x2F;image-20220614082038586.png)</p>
<p>It is helpful to view this definition in terms of a “space-time diagram” such as Figure 1. The horizontal direction represents space, and the vertical direction represents time–later times being higher than earlier ones. The dots denote events, the vertical lines denote processes, and the wavy lines denote messages. It is easy to see that a –&gt; b means that one can go from a to b in and message lines. For example, we have p1 –&gt; p4 in Figure 1.</p>
<p>该定义的另一种解释方式是，<code>a--&gt;b</code>表示事件<code>a</code>会对事件<code>b</code>产生因果影响。如果两个事件都不能对另一个产生因果影响，则两个事件是并发的。例如，图1中的事件<code>p3</code>和<code>q3</code>是并发的。尽管我们绘制的图中暗示<code>q3</code>的发生在物理时间上早于<code>p3</code>，但进程<code>P</code>在<code>p4</code>收到消息之前无法知道进程<code>Q</code>在<code>q3</code>做了什么。（在事件<code>p4</code>之前，<code>P</code>最多只能知道<code>Q</code>在<code>q3</code>计划做什么）</p>
<p>Another way of viewing the definition is to say that a –&gt; b means that it is possible for event a to causally affect event b. Two events are concurrent if neither can causally affect the other. For example, events p3 and q3 of Figure 1 are concurrent. Even though we have drawn the diagram to imply that q3 occurs at an earlier physical time than p3, process P cannot know what process Q did at q3 until it receives the message at p4. (Before event p4, P could at most know what Q was planning to do at q3)</p>
<p>对于熟悉狭义相对论不变时空公式的读者来说，这一定义将显得非常自然。</p>
<p>This definition will appear quite natural to the reader familiar with the invariant space-time formulation of special relativity, as described for example in [1] or the first chapter of [2]. In relativity, the ordering of events is defined in terms of messages that could be sent. However, we have taken the more pragmatic approach of only considering messages that actually are sent. We should be able to determine if a system performed correctly by knowing only those events which did occur, without knowing which events could have occurred.</p>
<hr>
<h3 id="Logical-Clocks"><a href="#Logical-Clocks" class="headerlink" title="Logical Clocks"></a>Logical Clocks</h3><p>现在把时钟引入到系统中。从一个抽象的观点开始，这个观点中，<font color=red>时钟就是为每个事件分配一个数字</font>，该数字表示事件发生的时间。更详细的说法是：为每个进程<code>Pi</code>定义一个时钟函数<code>Ci</code>，该函数可以为该进程中的每个事件<code>a</code>分配一个数字<code>Ci(a)</code>。而整个系统的时钟由函数<code>C</code>表示，它会为任一事件b分配一个<code>C(b)</code>，并且如果b是<code>Pj</code>进程中的时间的话，则<code>C(b) = Cj(b)</code>。目前我们没有对<code>Ci(a)</code>和物理时间的关系做任何的假设，所以可以认为<code>Ci</code>实际上就是一个逻辑时钟，而非物理时钟。</p>
<p>We now introduce clocks into the system. We begin with an abstract point of view in which a clock is just a way of assigning a number to an event, where the number is thought of as the time at which the event occurred. More precisely, we define a clock Ci for each process Pi to be a function which assigns a number Ci(a) to any event a in that process. The entire system of clocks is represented by the function C which assigns to any event b the number C(b), where C(b) &#x3D; Cj(b) if b is an event in process Pj. For now, we make no assumption about the relation of the numbers Ci(a) to physical time, so we can think of the clocks Ci as logical rather than physical clocks. They may be implemented by counters with no actual timing mechanism.</p>
<p>现在考虑这样一个时钟系统的<font color=red>正确性</font>。我们肯定不能基于物理时间来定义正确性，因为这需要进入物理时钟。因此正确性的定义必须是基于事件发生的顺序的。最合理的条件就是：如果一个事件<code>a</code>发生在事件<code>b</code>之前，那<code>a</code>应该发生在比<code>b</code>更早的时间。该条件语句正式描述是：</p>
<p><font color=red>Clock Condition</font>: 对于任意的事件<code>a</code>和<code>b</code>：如果<code>a--&gt;b</code>，那么<code>C(a) &lt; C(b)</code>.</p>
<p>We now consider what it means for such a system of clocks to be correct. We cannot base our definition of correctness on physical time, since that would require introducing clocks which keep physical time. Our definition must be based on the order in which events occur. The strongest reasonable condition is that if an event a occurs before another event b, then a should happen at an earlier time than b. We state this condition more formally as follows. </p>
<p>Clock Condition. For any events a, b: if a–&gt; b then C(a) &lt; C(b).</p>
<p>注意该命题的反命题不成立，否则的话就表示两个并发执行的事件必须发生在相同的时间，这显然是不成立的。（证明：如果反命题成立，即 <code>if C(a) &lt; C(b) then a--&gt;b</code>，则其逆反命题，即 <code>if a-/-&gt;b, then C(a) &gt;= C(b)</code> 也成立。<code>a</code>和<code>b</code>事件并发表示<code>a-/-&gt;b</code>，同时<code>b-/-&gt;a</code>，所以得到结论<code>C(a) &gt;= C(b)</code>，且<code>C(b) &gt;= C(a)</code>，所以<code>C(b) == C(a)</code>. 证毕）</p>
<p>Note that we cannot expect the converse condition to hold as well, since that would imply that any two concurrent events must occur at the same time. In Figure 1, p2 and p3 are both concurrent with q3, so this would mean that they both must occur at the same time as q3, which would contradict the Clock Condition because p2 –&gt; p3. </p>
<p>从我们对<code>&quot;--&gt;&quot;</code>关系的定义可以看出，如果满足下面两个条件的话，则Clock Condition也会得到满足：</p>
<ul>
<li><code>C1</code>. 如果<code>a</code>和<code>b</code>是进程<code>Pi</code>中的事件，并且<code>a</code>在<code>b</code>之前，则<code>Ci(a) &lt; Ci(b)</code>. </li>
<li><code>C2</code>. 如果<code>a</code>是<code>Pi</code>进程中发送消息的事件，而<code>b</code>是<code>Pj</code>进程中接收该消息的事件，则<code>Ci(a) &lt; Cj(b)</code>.</li>
</ul>
<p>It is easy to see from our definition of the relation “–&gt;” that the Clock Condition is satisfied if the following two conditions hold. </p>
<ul>
<li>C1. If a and b are events in process Pi, and a comes before b, then Ci(a) &lt; Ci(b). </li>
<li>C2. If a is the sending of a message by process Pi and b is the receipt of that message by process Pj, then Ci(a) &lt; Cj(b).</li>
</ul>
<p>现在从时空图的角度来考虑时钟。设想一个进程的时钟每次tick都会递增数字，tick发生在进程的事件之间。比如，假设<code>a</code>和<code>b</code>是进程<code>Pi</code>中相继出现的两个事件，<code>Ci(a)</code>为<code>4</code>，<code>Ci(b)</code>为<code>7</code>，时钟tick <code>5,6,7</code>发生在两个事件期间。我们画了一条虚线的tick线，穿过所有不同进程相同编号的tick。从而图1的时空图变成了图2那样。<code>C1</code>命题表示一个进程中两个事件之间必然有一条tick线，而<code>C2</code>命题则意味着每条消息线必然穿过一条tick线。从–&gt;的图示含义就很容易看出为什么这两个命题就能意味着Clock Condition的成立。</p>
<p>![image-20220616083214152](&#x2F;img&#x2F;Time,Clocks,and the Ordering of Events in a Distributed System&#x2F;image-20220616083214152.png)</p>
<p>Let us consider the clocks in terms of a space-time diagram. We imagine that a process’ clock “ticks” through every number, with the ticks occurring between the process’ events. For example, if a and b are consecutive events in process Pi with Ci(a) &#x3D; 4 and Ci(b) &#x3D; 7, then clock ticks 5, 6, and 7 occur between the two events. We draw a dashed “tick line” through all the like numbered ticks of the different processes. The spacetime diagram of Figure 1 might then yield the picture in Figure 2. Condition C1 means that there must be a tick line between any two events on a process line, and condition C2 means that every message line must cross a tick line. From the pictorial meaning of –&gt;, it is easy to see why these two conditions imply the Clock Condition.</p>
<p>我们可以将tick线视为时空上某个笛卡尔坐标系的时间坐标线。从而可以重新绘制图2来拉直这些坐标线，从而得到图3。图3是图2表示的相同的事件系统的有效替代方法。</p>
<p>![image-20220616083613225](&#x2F;img&#x2F;Time,Clocks,and the Ordering of Events in a Distributed System&#x2F;image-20220616083613225.png)</p>
<p>We can consider the tick lines to be the time coordinate lines of some Cartesian coordinate system on spacetime. We can redraw Figure 2 to straighten these coordinate lines, thus obtaining Figure 3. Figure 3 is a valid alternate way of representing the same system of events as Figure 2. Without introducing the concept of physical time into the system (which requires introducing physical clocks), there is no way to decide which of these pictures is a better representation.</p>
<p>The reader may find it helpful to visualize a two dimensional spatial network of processes, which yields a three-dimensional space-time diagram. Processes and messages are still represented by lines, but tick lines become two-dimensional surfaces.</p>
<p>现在假设进程是一种算法，事件表示算法执行过程中的某些操作。我们将展示在进程中引入时钟以满足Clock Condition。进程<code>Pi</code>的时钟由<code>Ci</code>表示，所以<code>Ci(a)</code>就表示事件a发生时从<code>Ci</code>获得的时钟值。<code>Ci</code>的值在事件发生期间进行递增，所以改变<code>Ci</code>的值本身并不是一个事件。</p>
<p>Let us now assume that the processes are algorithms, and the events represent certain actions during their execution. We will show how to introduce clocks into the processes which satisfy the Clock Condition. Process Pi’s clock is represented by a register Ci, so that Ci(a) is the value contained by Ci during the event a. The value of Ci  will change between events, so changing Ci does not itself constitute an event.</p>
<p><font color=red>为了保证系统时钟满足Clock Condition，我们需要满足<code>C1</code>和<code>C2</code>。</font>满足<code>C1</code>很简单，只要进程满足下面的规则：</p>
<p><font color=red><code>IR1</code></font>：每个进程<code>Pi</code>在两个相继的事件中间会增加<code>Ci</code>的值；</p>
<p>为了满足<code>C2</code>，需要每个消息<code>m</code>包含时间戳<code>Tm</code>，<code>Tm</code>就是该消息发送的时间戳。其他进程收到包含时间戳<code>Tm</code>的消息后，需要将其进程时钟调整到<code>Tm</code>后的时间，更精确的说法是：</p>
<p><font color=red><code>IR2</code></font>：(a)如果进程<code>Pi</code>的事件<code>a</code>发送消息<code>m</code>，那<code>m</code>中包含了时间戳<code>Tm</code>，<code>Tm</code>等于<code>Ci(a)</code>；(b)进程<code>Pj</code>收到消息<code>m</code>后，将其进程时钟<code>Cj</code>的值设置为大于<code>Tm</code>，且大于等于当前<code>Cj</code>的值；</p>
<p>在IR2(b)中，我们认为表示收到消息m的事件发生在设置Cj之后。显然，IR2能确保C2得到满足。因此，实现了规则IR1和IR2就意味着满足Clock Condition，因此它们保证了正确的逻辑时钟系统。</p>
<p>To guarantee that the system of clocks satisfies the Clock Condition, we will insure that it satisfies conditions C1 and C2. Condition C1 is simple; the processes need only obey the following implementation rule:</p>
<p>IR1. Each process Pi increments Ci between any two successive events.</p>
<p>To meet condition C2, we require that each message m contain a timestamp Tm which equals the time at which the message was sent. Upon receiving a message timestamped Tm, a process must advance its clock to be later than Tm. More precisely, we have the following rule.</p>
<p>IR2. (a) If event a is the sending of a message m by process Pi, then the message m contains a timestamp Tm &#x3D; Ci(a). (b) Upon receiving a message m, process Pj sets Cj greater than or equal to its present value and greater than Tm.</p>
<p>In IR2(b) we consider the event which represents the receipt of the message m to occur after the setting of Cj. (This is just a notational nuisance, and is irrelevant in any actual implementation.) Obviously, IR2 insures that C2 is satisfied. Hence, the simple implementation rules IR l and IR2 imply that the Clock Condition is satisfied, so they guarantee a correct system of logical clocks.</p>
<hr>
<h3 id="Ordering-the-Events-Totally-对事件全排序"><a href="#Ordering-the-Events-Totally-对事件全排序" class="headerlink" title="Ordering the Events Totally    对事件全排序"></a>Ordering the Events Totally    对事件全排序</h3><p>我们可以使用满足Clock Condition的时钟系统对所有系统事件集进行总排序。我们只是按照事件发生的时间来排序。为了打破联系，我们使用任意的进程全序关系<code>≺</code>（注意<code>≺</code>与<code>&lt;</code>不一样） 。更准确地说，我们<font color=red>定义一个关系<code>==&gt;</code>如下</font>：如果<code>a</code>是进程<code>Pi</code>中的事件，<code>b</code>是进程<code>Pj</code>中的事件，那么<code>a==&gt;b</code>当且仅当(i)<code>Ci(a)&lt;Cj(b)</code> 或(ii)<code>Ci(a)==Cj(b)</code>且<code>Pi≺Pj</code>。很容易看出，这是一种全序关系，Clock Condition意味着如果<code>a--&gt;b</code>，则<code>a==&gt;b</code>。换句话说，关系<code>==&gt;</code>是将“happened before”这种偏序<font color=red>扩展到全序</font>的一种方式。</p>
<p>We can use a system of clocks satisfying the Clock Condition to place a total ordering on the set of all system events. We simply order the events by the times at which they occur. To break ties, we use any arbitrary total ordering ≺ of the processes. More precisely, we define a relation &#x3D;&#x3D;&gt; as follows: if a is an event in process Pi and b is an event in process Pj, then a &#x3D;&#x3D;&gt; b if and only if either (i) Ci{a) &lt; Cj(b) or (ii) Ci(a) &#x3D;&#x3D;  Cj(b) and Pi ≺ Pj. It is easy to see that this defines a total ordering, and that the Clock Condition implies that if a –&gt; b then a &#x3D;&#x3D;&gt; b. In other words, the relation &#x3D;&#x3D;&gt; is a way of completing the “happened before” partial ordering to a total ordering.</p>
<p>排序<code>==&gt;</code>取决于时钟系统<code>Ci</code>，并且不是唯一的。选择满足Clock Condition的不同时钟会产生不同的<code>==&gt;</code>关系（个人理解：每个进程的逻辑时钟可以自行决定tick的频率，只要满足IR1和IR2即可。比如Ci和Cj，如果Ci每秒递增10个tick，而Cj每秒递增100个tick，则Pi和Pj不相关的事件，一般是Pi的事件排在前面，一旦二者的事件之间有交互，只要按照IR2的规则调整Ci就可以）。给定任何扩展<code>--&gt;</code>的全序关系<code>==&gt;</code>，总有一个满足Clock Condition的时钟系统能产生该关系。只有偏序才是由系统中的事件唯一确定的。</p>
<p>The ordering &#x3D;&#x3D;&gt; depends upon the system of clocks Ci, and is not unique. Different choices of clocks which satisfy the Clock Condition yield different relations &#x3D;&#x3D;&gt;. Given any total ordering relation &#x3D;&#x3D;&gt; which extends –&gt;, there is a system of clocks satisfying the Clock Condition which yields that relation. It is only the partial ordering which is uniquely determined by the system of events.</p>
<p>能够定义事件的全序关系对于实现分布式系统非常有用。事实上，实现正确的逻辑时钟系统的原因就是为了获得这样的全序关系。我们将通过解决下面的互斥问题来说明事件全序关系的使用。考虑一个由若干进程组成的系统，这些进程共享单个资源。一次只能有一个进程使用该资源，因此这些进程必须同步以避免冲突。我们希望找到一种用于将资源授予进程的算法，它满足以下三个条件：</p>
<ul>
<li>(I) 已授予资源的进程必须先释放资源，然后该资源才能授予另一个进程。</li>
<li>(II) 对资源的请求必须按照请求的顺序授予资源。</li>
<li>(III) 如果每个被授予资源的进程最终都会释放它，那么每个请求最终都会被授予。</li>
</ul>
<p>Being able to totally order the events can be very useful in implementing a distributed system. In fact, the reason for implementing a correct system of logical clocks is to obtain such a total ordering. We will illustrate the use of this total ordering of events by solving the following version of the mutual exclusion problem. Consider a system composed of a fixed collection of processes which share a single resource. Only one process can use the resource at a time, so the processes must synchronize themselves to avoid conflict. We wish to find an algorithm for granting the resource to a process which satisfies the following three conditions: (I) A process which has been granted the resource must release it before it can be granted to another process. (II) Different requests for the resource must be granted in the order in which they are made. (III) If every process which is granted the resource eventually releases it, then every request is eventually granted.</p>
<p>假设初始情况下，资源被授予了单个进程。</p>
<p>这些都是非常自然的要求。它们精确地指定了解决方案为何正确的含义。考虑上面涉及事件顺序的条件，条件II没有对并发产生的请求，哪个应该先被授予请求有任何要求。</p>
<p>必须认识到这是一个非常重要的问题。除非做出额外的假设，否则使用中央调度进程来将资源按照收到请求的顺序进行授予是无法满足条件的。假设<code>P0</code>就是中央调度进程，<code>P1</code>向<code>P0</code>发送请求，然后向<code>P2</code>发了一个消息，收到消息后，<code>P2</code>向<code>P0</code>发送请求。<code>P2</code>的请求可能在<code>P1</code>的请求到达<code>P0</code>之前先到达。如果<code>P2</code>的请求首先被批准，则违反条件II。</p>
<p>We assume that the resource is initially granted to exactly one process.</p>
<p>These are perfectly natural requirements. They precisely specify what it means for a solution to be correct. Observe how the conditions involve the ordering of events. Condition II says nothing about which of two concurrently issued requests should be granted first.</p>
<p>It is important to realize that this is a nontrivial problem. Using a central scheduling process which grants requests in the order they are received will not work, unless additional assumptions are made. To see this, let P0 be the scheduling process. Suppose P1 sends a request to P0 and then sends a message to P2. Upon receiving the latter message, P2 sends a request to P0. It is possible for P2’s request to reach P0 before Pl’s request does. Condition II is then violated if P2’s request is granted first.</p>
<p>为了解决这个问题，我们使用规则<code>IR1</code>和<code>IR2</code>实现了一个时钟系统，并使用它们定义所有事件的全序关系<code>==&gt;</code>。这提供了所有请求和释放操作的全序关系。通过这种排序，解决方法变得很简单。它只需确保每个进程能了解所有其他进程的操作。</p>
<p>To solve the problem, we implement a system of clocks with rules IR1 and IR2, and use them to define a total ordering &#x3D;&#x3D;&gt; of all events. This provides a total ordering of all request and release operations. With this ordering, finding a solution becomes a straightforward exercise. It just involves making sure that each process learns about all other processes’ operations.</p>
<p>为了简化问题，我们做了如下的假设，它们不是必需的，但引入它们是为了避免分散注意力到实现细节上：</p>
<ul>
<li>假设对于任何两个进程<code>Pi</code>和<code>Pj</code>，从<code>Pi</code>发送到<code>Pj</code>的消息的接收顺序与发送顺序相同。</li>
<li>假设每个消息最终都会被接收到。</li>
<li>假设一个进程可以直接向其他每个进程发送消息。</li>
</ul>
<p>To simplify the problem, we make some assumptions. They are not essential, but they are introduced to avoid distracting implementation details. We assume first of all that for any two processes P&#x2F;and Pj, the messages sent from Pi to Pi are received in the same order as they are sent. Moreover, we assume that every message is eventually received. (These assumptions can be avoided by introducing message numbers and message acknowledgment protocols.) We also assume that a process can send messages directly to every other process.</p>
<p>每个进程都维护自己内部的请求队列，该队列外部不可见。假设请求队列最初包含一个消息<code>T0:P0</code>，其中<code>P0</code>是最初被授予资源的进程，<code>T0</code>小于任何时钟的初始值。</p>
<p>Each process maintains its own request queue which is never seen by any other process. We assume that the request queues initially contain the single message T0:P0 requests resource, where P0 is the process initially granted the resource and T0 is less than the initial value of any clock.</p>
<p>该算法由下面的5条规则定义：</p>
<ol>
<li>为了请求资源，进程<code>Pi</code>向其他每个进程发送消息<code>Tm:Pi</code> 请求资源，并将该消息放在其请求队列中，其中<code>Tm</code>是消息的时间戳。</li>
<li>当进程<code>Pj</code>接收到消息<code>Tm:Pi</code> 时，将其放在其请求队列中，并向<code>Pi</code>发送（附带时间戳）确认消息。</li>
<li>为了释放资源，进程<code>Pi</code>从其请求队列中删除所有<code>Tm:Pi</code> 消息，并向其他每个进程发送一条（附带时间戳）<code>Pi</code> 释放资源消息。</li>
<li>当进程<code>Pj</code> 收到 <code>Pi</code> 释放资源消息时，它会从其请求队列中删除所有<code>Tm:Pi</code> 消息。</li>
<li>当满足以下两个条件时，进程<code>Pi</code>被授予资源：(i) 其请求队列中有一条<code>Tm:Pi</code> 消息，该消息按<code>==&gt;</code>关系排序，排在队列中任何其他请求资源消息之前（为了定义消息的<code>“==&gt;”</code>关系，我们用发送事件来标识消息）。(ii) <code>Pi</code>已从其他每个进程接收到时间戳晚于<code>Tm</code>的消息。</li>
</ol>
<p>上述规则5中的(i)和(ii)规则都由进程<code>Pi</code>自行检测。</p>
<p>The algorithm is then defined by the following five rules. For convenience, the actions defined by each rule are assumed to form a single event.</p>
<ol>
<li><p>To request the resource, process Pi sends the message Tm:Pi requests resource to every other process, and puts that message on its request queue, where Tm is the timestamp of the message.</p>
</li>
<li><p>When process Pj receives the message Tm:Pi requests resource, it places it on its request queue and sends a (timestamped) acknowledgment message to Pi.</p>
</li>
<li><p>To release the resource, process Pi removes any Tm:Pi requests resource message from its request queue and sends a (timestamped) Pi releases resource message to every other process.</p>
</li>
<li><p>When process Pj receives a Pi releases resource message, it removes any Tm:Pi requests resource message from its request queue.</p>
</li>
<li><p>Process Pi is granted the resource when the following two conditions are satisfied: (i) There is a Tm:Pi requests resource message in its request queue which is ordered before any other request in its queue by the relation &#x3D;&#x3D;&gt;. (To define the relation “&#x3D;&#x3D;&gt;” for messages, we identify a message with the event of sending it.) (ii) Pi has received a message from every other process timestamped later than Tm.</p>
</li>
</ol>
<p>Note that conditions (i) and (ii) of rule 5 are tested locally by Pi.</p>
<p>很容易验证这些规则定义的算法满足条件I-III。首先，考虑规则5的条件(ii)以及消息按顺序接收的假设，可以确保<code>Pi</code>已经了解了当前请求之前的所有请求。由于规则3和4是唯一从请求队列中删除消息的规则，因此很容易得到条件I被满足了。条件II源自这样一个事实，即全序关系<code>==&gt;</code>扩展了偏序关系<code>--&gt;</code>。规则2保证在<code>Pi</code>请求资源后，规则5的条件(ii)最终将得到满足。规则3和4意味着，如果每个被授予资源的进程最终释放了资源，那么规则5的条件(i)最终将被满足，从而证明条件III。</p>
<p>It is easy to verify that the algorithm defined by these rules satisfies conditions I-III. First of all, observe that condition (ii) of rule 5, together with the assumption that messages are received in order, guarantees that Pi has learned about all requests which preceded its current request. Since rules 3 and 4 are the only ones which delete messages from the request queue, it is then easy to see that condition I holds. Condition II follows from the fact that the total ordering &#x3D;&#x3D;&gt; extends the partial ordering –&gt;. Rule 2 guarantees that after Pi requests the resource, condition (ii) of rule 5 will eventually hold. Rules 3 and 4 imply that if each process which is granted the resource eventually releases it, then condition (i) of rule 5 will eventually hold, thus proving condition III.</p>
<p>这是一个分布式的算法。每个进程都独立地遵循这些规则，并且没有中央同步进程或中央存储。这种方法可以泛化为实现分布式多进程系统所需的任何同步。同步以<font color=red>状态机</font>的形式指定，状态机由一组可能的命令<code>C</code>、一组可能的状态<code>S</code>和一个函数<code>e</code>: <code>C×S-&gt;S</code>组成。 <code>e(C, S) = S&#39;</code>表示状态机处于<code>S</code>状态时执行命令<code>C</code>会导致状态机状态变为<code>S’</code>。在我们的示例中，集合<code>C</code>由所有<code>Pi</code> requests resource命令和<code>Pi</code> releases resource命令组成，状态由等待requests命令的队列组成，其中队列头部的请求是当前被授予的请求。执行requests 命令会将requests 添加到队列的尾部，执行releases 命令会从“队列”中删除命令。</p>
<p>This is a distributed algorithm. Each process independently follows these rules, and there is no central synchronizing process or central storage. This approach can be generalized to implement any desired synchronization for such a distributed multiprocess system. The synchronization is specified in terms of a State Machine, consisting of a set C of possible commands, a set S of possible states, and a function e: C×S-&gt;S. The relation e(C, S) – S’ means that executing the command C with the machine in state S causes the machine state to change to S’. In our example, the set C consists of all the commands Pi requests resource and Pi releases resource, and the state consists of a queue of waiting request commands, where the request at the head of the queue is the currently granted one. Executing a request command adds the request to the tail of the queue, and executing a release command removes a command from the queue.</p>
<p>每个进程使用所有进程发出的命令，独立地驱动状态机的执行。能够实现同步是因为所有进程都根据其时间戳（使用关系<code>==&gt;</code>）对命令进行排序，因此每个进程使用的是相同的命令序列。当一个进程收到所有进发来的时间戳小于或等于<code>T</code>的所有命令时，它就可以执行时间戳为<code>T</code>的命令。算法精确描述很简单，我们不必费心描述它。</p>
<p>Each process independently simulates the execution of the State Machine, using the commands issued by all the processes. Synchronization is achieved because all processes order the commands according to their timestamps (using the relation &#x3D;&#x3D;&gt;), so each process uses the same sequence of commands. A process can execute a command timestamped T when it has learned of all commands issued by all other processes with timestamps less than or equal to T. The precise algorithm is straightforward, and we will not bother to describe it.</p>
<p>这种方法允许在分布式系统中实现任何所需形式的多进程同步。然而，该算法需要所有进程的积极参与。一个进程必须知道其他进程发出的所有命令，因此单个进程的故障将使其他任何进程都无法执行状态机命令，从而系统停止。</p>
<p>This method allows one to implement any desired form of multiprocess synchronization in a distributed system. However, the resulting algorithm requires the active participation of all the processes. A process must know all the commands issued by other processes, so that the failure of a single process will make it impossible for any other process to execute State Machine commands, thereby halting the system.</p>
<p>故障问题是一个困难的问题，详细讨论它超出了本文的范围。我们注意到，故障的概念只有在物理时间的背景下才有意义。没有物理时间，就无法区分一个进程是故障了，还是只是在事件间暂停了。用户可以判断系统“崩溃”，仅仅是因为他等待响应的时间太长。论文《The implementation of reliable distributed multiprocess systems》中描述了一种即使单个进程或通信线路出现故障也能正常工作的方法。</p>
<p>The problem of failure is a difficult one, and it is beyond the scope of this paper to discuss it in any detail. We will just observe that the entire concept of failure is only meaningful in the context of physical time. Without physical time, there is no way to distinguish a failed process from one which is just pausing between events. A user can tell that a system has “crashed” only because he has been waiting too long for a response. A method which works despite the failure of individual processes or communication lines is described in [3].</p>
<hr>
<h3 id="Anomalous-Behavior-反常行为"><a href="#Anomalous-Behavior-反常行为" class="headerlink" title="Anomalous Behavior     反常行为"></a>Anomalous Behavior     反常行为</h3><p>我们的资源调度算法根据全序关系<code>==&gt;</code>，对请求进行排序。这允许出现下面这种“异常行为”：考虑一个全国范围的互联计算机系统。假设一个人在计算机A上发出请求<code>a</code>，然后打电话给另一个城市的朋友，让他在另一台计算机B上发出请求<code>b</code>。请求<code>b</code>很可能附带较小的时间戳，并排在在请求<code>a</code>之前。这可能发生，因为系统无法知道<code>a</code>实际上在<code>b</code>之前，因为<code>a</code>和<code>b</code>谁先谁后这个信息是基于系统外部的电话消息。</p>
<p>Our resource scheduling algorithm ordered the requests according to the total ordering &#x3D;&#x3D;&gt;. This permits the following type of “anomalous behavior.” Consider a nationwide system of interconnected computers. Suppose a person issues a request A on a computer A, and then telephones a friend in another city to have him issue a request B on a different computer B. It is quite possible for request B to receive a lower timestamp and be ordered before request A. This can happen because the system has no way of knowing that A actually preceded B, since that precedence information is based on messages external to the system.</p>
<p>让我们更仔细地检查问题的根源。设 F 为所有系统事件的集合。让我们引入事件集 <u>F</u> ，其中包含 F 中的事件以及所有其他相关的外部事件，比如上面示例中的电话呼叫。用 <strong>–&gt;</strong> 表示 <u>F</u> 中的“happened before”关系。在我们的示例中，我们有 <code>a</code><strong>–&gt;</strong><code>b</code>，但<code>a-/-&gt;b</code>。很明显，没有任何算法可以完全基于 F 中的事件，且不以任何方式将这些事件与 <u>F</u> 中的其他事件关联起来，来保证请求<code>a</code>排在请求<code>b</code>之前。</p>
<p>Let us examine the source of the problem more closely. Let F be the set of all system events. Let us introduce a set of events which contains the events in F together with all other relevant external events, such as the phone calls in our example. Let <strong>–&gt;</strong> denote the “happened before” relation for <u>F</u>. In our example, we had A <strong>–&gt;</strong> B, but A -&#x2F;-&gt; B. It is obvious that no algorithm based entirely upon events in F, and which does not relate those events in any way with the other events in <u>F</u>, can guarantee that request A is ordered before request B.</p>
<p>有两种可能的方法可以避免这种异常行为。第一种方法是在系统中明确引入有关 <strong>–&gt;</strong> 关系的必要信息。在我们的示例中，发出请求<code>a</code>的人可以从系统中得到接收该请求的时间戳<code>Ta</code>。当发出请求<code>b</code>时，他的朋友可以指定<code>b</code>的时间戳晚于<code>Ta</code>。这就是让用户来负责避免异常行为。</p>
<p>There are two possible ways to avoid such anomalous behavior. The first way is to explicitly introduce into the system the necessary information about the ordering <strong>–&gt;</strong>. In our example, the person issuing request A could receive the timestamp Ta of that request from the system. When issuing request B, his friend could specify that B be given a timestamp later than Ta. This gives the user the responsibility for avoiding anomalous behavior.</p>
<p>第二种方法是构造一个满足以下条件的时钟系统。<font color=red>Strong Clock Condition</font>：对于 F 中的任何事件<code>a、b</code>：如果<code>a</code><strong>–&gt;</strong><code>b</code>，则<code>C(a) &lt; C(b)</code>。</p>
<p>The second approach is to construct a system of clocks which satisfies the following condition.</p>
<p>Strong Clock Condition. For any events a, b in F: if a <strong>–&gt;</strong> b then C(a} &lt; C(b).</p>
<p>这比Clock Condition强，因为 <strong>–&gt;</strong> 的关系比–&gt;强。一般来说，逻辑时钟无法满足该条件。</p>
<p>This is stronger than the ordinary Clock Condition because <strong>–&gt;</strong> is a stronger relation than –&gt;. It is not in general satisfied by our logical clocks.</p>
<p>让我们用物理时空中的一组“真实”事件来标识 <u>F</u> ，并让 <strong>–&gt;</strong> 是狭义相对论定义的事件的偏序。宇宙的奥秘之一，是有可能构建一个物理时钟系统，该系统彼此独立运行，并能满足Strong Clock Condition。因此，我们可以使用物理时钟来消除异常行为。我们现在把注意力转向物理时钟。</p>
<p>Let us identify <u>F</u> with some set of “real” events in physical space-time, and let <strong>–&gt;</strong> be the partial ordering of events defined by special relativity. One of the mysteries of the universe is that it is possible to construct a system of physical clocks which, running quite independently of one another, will satisfy the Strong Clock Condition. We can therefore use physical clocks to eliminate anomalous behavior. We now turn our attention to such clocks.</p>
<hr>
<h3 id="Physical-Clocks"><a href="#Physical-Clocks" class="headerlink" title="Physical Clocks"></a>Physical Clocks</h3><p>现在在时空图中引入一个物理时间坐标，用<code>Ci(t)</code>表示在物理时间<code>t</code>时对时钟<code>Ci</code>的读数。出于数学上的方便, 我们假设时钟是连续运转的，而不是离散的”ticks”。更准确地说，我们假定除了时钟重置时的孤立的跳跃不连续点外, <code>Ci(t)</code>是一个连续的、对<code>t</code>可微的函数。从而 <code>dCi(t)/dt</code> 表示时钟在<code>t</code>时刻的运行速率.</p>
<p>Let us introduce a physical time coordinate into our space-time picture, and let Ci(t) denote the reading of the clock Ci at physical time t. For mathematical convenience, we assume that the clocks run continuously rather than in discrete “ticks.” (A discrete clock can be thought of as a continuous one in which there is an error of up to ½ “tick” in reading it.) More precisely, we assume that Ci(t) is a continuous, differentiable function of t except for isolated jump discontinuities where the clock is reset. Then dCi(t)&#x2F;dt represents the rate at which the clock is running at time t.</p>
<p>为了使时钟<code>Ci(t)</code>成为一个真正的物理时钟，它必须以大概正确的速度运行。即，对于所有<code>t</code>，必须有<code>dCi(t)/dt ≈ 1</code>。更准确地说，我们假设满足以下条件:</p>
<p><strong>PC1</strong>. 存在一个常量<code>x &lt;&lt; 1</code>, 对于所有的 <code>i</code>满足: <code>| dCi(t)/dt - 1 | &lt; x</code>. 在典型的晶体控制的时钟中, <code>x &lt;=</code> 10<sup>-6</sup>.</p>
<p>In order for the clock Ci to be a true physical clock, it must run at approximately the correct rate. That is, we must have dCi(t)&#x2F;dt ≈ 1 for all t. More precisely, we will assume that the following condition is satisfied:</p>
<p>PCI. There exists a constant x &lt;&lt; 1, such that for all i: | dCi(t)&#x2F;dt - 1 | &lt; x. For typical crystal controlled clocks, x &lt;&#x3D; 10<sup>-6</sup>.</p>
<p>仅使各时钟以大约正确的速度运行是不够的。它们还必须尽可能的同步，使得对于所有的<code>i,j</code>和<code>t</code>, <code>Ci(t) ≈ Cj(t)</code>。更准确地说，必须有一个足够小的常数<code>e</code> ，使下列条件成立:</p>
<p><strong>PC2</strong>.对于所有<code>i, j</code> : <code>| Ci(t) - Cj(t) | &lt; e</code></p>
<p>It is not enough for the clocks individually to run at approximately the correct rate. They must be synchronized so that Ci(t) ≈ Cj(t) for all i,j, and t. More precisely, there must be a sufficiently small constant e so that the following condition holds:</p>
<p>PC2. For all i, j: | Ci(t) - Cj(t) | &lt; e.</p>
<p>如果我们考虑图2中的垂直距离来表示物理时间，那么PC2表示单个刻度线的高度变化小于e。</p>
<p>If we consider vertical distance in Figure 2 to represent physical time, then PC2 states that the variation in height of a single tick line is less than e.</p>
<p>由于两个不同的时钟永远不会以完全相同的速度运行，它们会越走越远。因此，我们必须设计一种算法来确保PC2始终有效。然而, 首先，让我们检查<code>x</code>和<code>e</code>必须要多小才能阻止异常行为。我们必须确保相关物理事件的系统 <u>F</u> 满足Strong Clock Condition。我们假设我们的时钟满足普通Clock Condition，因此我们只需要保证对于 <u>F</u> 中满足 <code>a</code><strong>–&gt;</strong><code>b</code> 的事件<code>a, b</code>, Strong Clock Condition成立. 因此，我们只需要考虑发生在不同进程中的事件。</p>
<p>Since two different clocks will never run at exactly the same rate, they will tend to drift further and further apart. We must therefore devise an algorithm to insure that PC2 always holds. First, however, let us examine how small x and e must be to prevent anomalous behavior. We must insure that the system <u>F</u> of relevant physical events satisfies the Strong Clock Condition. We assume that our clocks satisfy the ordinary Clock Condition, so we need only require that the Strong Clock Condition holds when a and b are events in F with a <strong>-&#x2F;-&gt;</strong> b. Hence, we need only consider events occurring in different processes.</p>
<p>假设<code>u</code>是一个数字，如果事件<code>a</code>发生在物理时间<code>t</code>，而另一个进程中的事件<code>b</code>满足 a**–&gt;**b，则<code>b</code>发生在物理时间<code>t+u</code>之后。换句话说，<code>u</code>小于进程间消息的最短传输时间。我们总是可以选择<code>u</code>等于过程之间的最短距离除以光速。但是，根据 <u>F</u> 中的消息的传输方式，<code>u</code>可能要大得多。</p>
<p>Let u be a number such that if event a occurs at physical time t and event b in another process satisfies a ~ b, then b occurs later than physical time t + u. In other words, u is less than the shortest transmission time for interprocess messages. We can always choose # equal to the shortest distance between processes divided by the speed of light. However, depending upon how messages in <u>F</u> are transmitted, u could be significantly larger.</p>
<p>为了避免异常行为, 我们必须保证对任意<code>i, j, t</code>: <code>Ci(t + u) - Cj(t) &gt; 0</code>. 将这个条件与PC1和PC2结合起来，我们可以将<code>x</code>和<code>e</code>的最小值与<code>u</code>的值联系起来，如下所示。我们假定当时钟被重置时，它总是向前拨，而不会后退。(允许往后拨会导致违反C1). PC1暗示<code>Ci(t + u) - Ci(t) &gt; (1 - x)u</code>. 使用PC2, 很容易推导出当<code>e/(1-x) &lt;= u</code>时 <code>Ci(t + u) - Cj(t) &gt; 0</code>。</p>
<p>To avoid anomalous behavior, we must make sure that for any i, j, and t: Ci(t + u) - Cj(t) &gt; 0. Combining this with PCI and 2 allows us to relate the required smallness of x and e to the value of # as follows. We assume that when a clock is reset, it is always set forward and never back. (Setting it back could cause C1 to be violated.) PCI then implies that Ci(t + u) - Ci(t) &gt; (1 - x)u. Using PC2, it is then easy to deduce that Ci(t + u) - Cj(t) &gt; 0 if the following inequality holds: e&#x2F;(1-x) &lt;&#x3D; u.</p>
<p>这个不等式以及PC1和PC2表明反常行为是不可能的。</p>
<p>This inequality together with PC 1 and PC2 implies that anomalous behavior is impossible.</p>
<p>现在我们描述确保PC2成立的算法。设<code>m</code>是在物理时间t发送并在时间<code>t&#39;</code>接收的消息. 我们定义<code>vm=t&#39;-t</code>是消息<code>m</code>的total delay (总延迟). 当然，这个延迟接收<code>m</code>的进程所不知道的。然而, 我们假设接收进程知道一些minimum delay (最小延迟)  <code>um &gt;= 0</code> 使得 <code>um &lt;= vm</code> . 我们称 <code>zm = vm-um</code> 是消息的unpredictable delay (不可预测延迟)</p>
<p>我们现在指定针对物理时钟的IRI和IR2规则如下:</p>
<p><strong>IR1’</strong>. 对于任意<code>i</code>, 如果<code>Pi</code>没有在物理时间<code>t</code>收到消息, 那么<code>Ci</code>是在<code>t</code>点可微, 且<code>dCi(t)/dt &gt; 0</code></p>
<p><strong>IR2’</strong>. (a) 如果<code>Pi</code>在物理时间<code>t</code>发送消息<code>m</code>, 那么<code>m</code>包含时间戳<code>Tm= Ci(t)</code>. (b) 当在时间<code>t&#39;</code>收到消息<code>m</code>, 进程<code>Pj</code>设置<code>Cj(t&#39;)</code>为 <code>max(Cj(t&#39; - 0), Tm + um)</code>. (其中<img src="https://www.zhihu.com/equation?tex=C_j(t%27-0)=lim_%7B%5Cdelta%5Crightarrow+0%7DC_j(t%27-%7C%5Cdelta%7C)" alt="[公式]"> )</p>
<p>We now describe our algorithm for insuring that PC2 holds. Let m be a message which is sent at physical time t and received at time t’. We define vm &#x3D; t’ - t to be the total delay of the message m. This delay will, of course, not be known to the process which receives m. However, we assume that the receiving process knows some minimum delay um &gt;&#x3D; 0 such that um &lt;&#x3D; vm. We call zm &#x3D; vm-um the unpredictable delay of the message.</p>
<p>We now specialize rules IRI and 2 for our physical clocks as follows:</p>
<p>IR 1’. For each i, if Pi does not receive a message at physical time t, then Ci is differentiable at t and dCi(t)&#x2F;dt &gt; 0.</p>
<p>IR2’. (a) If Pi sends a message m at physical time t, then m contains a timestamp Tm&#x3D; Ci(t). (b) Upon receiving a message m at time t’, process Pj sets Cj(t’) equal to maximum (Cj(t’ - 0), Tm + um). </p>
<p>虽然规则是用物理时间参数正式指定的，但进程只需要知道自己的时钟读数和它接收到的消息的时间戳。为了数学上的方便，我们假设每个事件都发生在物理时间的精确瞬间，而同一进程中的不同事件发生在不同的时间。这些规则是规则IR1和规则IR2的特殊化，因此我们的时钟系统满足Clock Condition。真实事件的持续时间是有限的，因此实现该算法方面没有任何困难。在实现中唯一真正需要关注的是确保离散时钟滴答声足够频繁，以便C1得到维护。</p>
<p>Although the rules are formally specified in terms of the physical time parameter, a process only needs to know its own clock reading and the timestamps of messages it receives. For mathematical convenience, we are assuming that each event occurs at a precise instant of physical time, and different events in the same process occur at different times. These rules are then specializations of rules IR1 and IR2, so our system of clocks satisfies the Clock Condition. The fact that real events have a finite duration causes no difficulty in implementing the algorithm. The only real concern in the implementation is making sure that the discrete clock ticks are frequent enough so C 1 is maintained.</p>
<p>我们现在证明这个时钟同步算法可以满足条件PC2。我们假设进程系统是用一个有向图来描述的，其中从进程<code>Pi</code>到进程<code>Pj</code>的弧表示一条通信线，消息从<code>Pi</code>直接发送到<code>Pj</code>。我们说每<code>π</code>秒在这个弧上发送一条消息, 当对于任意<code>t</code>, <code>Pi</code>在物理时间<code>t</code>和<code>t+π</code>之间至少发送一条消息给<code>Pj</code>。有向图的直径diameter是一个最小值<code>d</code>, 使得任意一对不同的过程<code>Pj</code>，<code>Pk</code>，从<code>Pj</code>到<code>Pk</code> 有一条路径，该路径最多有<code>d</code>条弧。</p>
<p>We now show that this clock synchronizing algorithm can be used to satisfy condition PC2. We assume that the system of processes is described by a directed graph in which an arc from process Pi to process Pj represents a communication line over which messages are sent directly from Pi to Pj. We say that a message is sent over this arc every T seconds if for any t, Pi sends at least one message to Pj between physical times t and t + -r. The diameter of the directed graph is the smallest number d such that for any pair of distinct processes Pj, Pk, there is a path from Pj to Pk having at most d arcs.</p>
<p>除了建立PC2之外，下面的定理限制了系统第一次启动时时钟可以同步的时间长度。</p>
<p>In addition to establishing PC2, the following theorem bounds the length of time it can take the clocks to become synchronized when the system is first started.</p>
<p><strong>THEOREM</strong>. 假设一个直径为<code>d</code>的进程的强连通图，它始终保证规则<code>IR1&#39;</code>和<code>IR2&#39;</code>的成立。假设对任意消息<code>m</code>, 存在某个参数<code>u</code>使得<code>um &lt;= u</code> , 并且让所有<code>t &gt;= t0</code> : (a) PC1成立 (b) 存在参数<code>π, z</code> , 使得每<code>π</code>秒, 一个unpredictable delay小于<code>z</code>的消息在每个弧中发送. 从而PC2满足条件, 且对于任意<code>t&gt;=t0+πd</code>，有<code>e</code>约等于<code>d(2kπ + z)</code>， 其中约等于条件假定了<code>u+z &lt;&lt; π</code>.</p>
<p>THEOREM. Assume a strongly connected graph of processes with diameter d which always obeys rules IR1’ and IR2’. Assume that for any message m, um &lt;&#x3D; u for some constant u, and that for all t &gt; t0: (a) PC 1 holds. (b) There are constants π and z such that every π seconds a message with an unpredictable delay less than z is sent over every arc. Then PC2 is satisfied with e ≈d(2kπ + z) for all t&gt;&#x3D;t0+πd, where the approximations assume u+z &lt;&lt; π.</p>
<p>这个定理的证明是非常困难的，在附录中给出。在同步物理时钟的问题上已经做了大量的工作。我们请读者参考[4]来了解这个主题。文献中描述的方法对于估计消息延迟<code>um</code>和调整时钟频率<code>dCi/dt</code> (对于允许这样调整的时钟)是有用的。然而，时钟永远不能倒拨的要求似乎将我们的情况与之前研究过的情况区分开来，我们相信这个定理是一个新的结果。</p>
<p>The proof of this theorem is surprisingly difficult, and is given in the Appendix. There has been a great deal of work done on the problem of synchronizing physical clocks. We refer the reader to [4] for an intro-duction to the subject. The methods described in the literature are useful for estimating the message delays ktm and for adjusting the clock frequencies dCi&#x2F;dt (for clocks which permit such an adjustment). However, the requirement that clocks are never set backwards seems to distinguish our situation from ones previously studied, and we believe this theorem to be a new result.</p>
<hr>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>我们已经看到，“happening before”的概念定义了分布式多进程系统中事件的偏序关系。我们描述了一种将偏序扩展为全序的算法，并展示了如何使用该全序关系来解决一个简单的同步问题。未来的一篇论文将展示如何扩展此方法以解决任何同步问题。</p>
<p>We have seen that the concept of “happening before” defines an invariant partial ordering of the events in a distributed multiprocess system. We described an algorithm for extending that partial ordering to a somewhat arbitrary total ordering, and showed how this total ordering can be used to solve a simple synchronization problem. A future paper will show how this approach can be extended to solve any synchronization problem.</p>
<p>该算法定义的全序关系是任意的。如果它与系统用户感知到的顺序不一致，可能会产生异常行为。该问题可以通过使用正确同步的物理时钟来防止。我们的定理表明了时钟可以同步到多近。</p>
<p>The total ordering defined by the algorithm is somewhat arbitrary. It can produce anomalous behavior if it disagrees with the ordering perceived by the system’s users. This can be prevented by the use of properly synchronized physical clocks. Our theorem showed how closely the clocks can be synchronized.</p>
<p>在分布式系统中，重要的是要认识到事件发生的顺序只是偏序。我们相信这个想法对于理解任何多进程系统都是有用的。它应该有助于人们在不依赖于解决这些问题的机制的情况下，理解多进程的根本问题。</p>
<p>In a distributed system, it is important to realize that the order in which events occur is only a partial ordering. We believe that this idea is useful in understanding any multiprocess system. It should help one to understand the basic problems of multiprocessing independently of the mechanisms used to solve them.</p>
<hr>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/484914733">https://zhuanlan.zhihu.com/p/484914733</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/484914733#ref_1">https://zhuanlan.zhihu.com/p/484914733#ref_1</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/87944336">https://zhuanlan.zhihu.com/p/87944336</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34057588">https://zhuanlan.zhihu.com/p/34057588</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://lamport.azurewebsites.net/pubs/pubs.html#time-clocks">https://lamport.azurewebsites.net/pubs/pubs.html#time-clocks</a></p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag"># 分布式</a>
              <a href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/" rel="tag"># 一致性</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/06/15/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7/jepsen/16Read%20Committed/" rel="prev" title="16Read Committed">
      <i class="fa fa-chevron-left"></i> 16Read Committed
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/06/25/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7/jepsen/17Read%20Uncommitted/" rel="next" title="17Read Uncommitted">
      17Read Uncommitted <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Partial-Ordering"><span class="nav-number">2.</span> <span class="nav-text">The Partial Ordering</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Logical-Clocks"><span class="nav-number">3.</span> <span class="nav-text">Logical Clocks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ordering-the-Events-Totally-%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%85%A8%E6%8E%92%E5%BA%8F"><span class="nav-number">4.</span> <span class="nav-text">Ordering the Events Totally    对事件全排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Anomalous-Behavior-%E5%8F%8D%E5%B8%B8%E8%A1%8C%E4%B8%BA"><span class="nav-number">5.</span> <span class="nav-text">Anomalous Behavior     反常行为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Physical-Clocks"><span class="nav-number">6.</span> <span class="nav-text">Physical Clocks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Conclusion"><span class="nav-number">7.</span> <span class="nav-text">Conclusion</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="gqtc"
      src="/images/panda.gif">
  <p class="site-author-name" itemprop="name">gqtc</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">gqtc</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'DOtutT1RryAIysn71vbzynQy-gzGzoHsz',
      appKey     : 'KxMi4qDudMqAUjo5HbMTp5Ht',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
